"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_SAFE_VALUE_i32 = exports.getCompositeTypeFieldsRecursively = exports.getFieldTypesFromCurrentBlock = exports.getFieldsFromCurrentBlock = exports.getAllPreviewFeaturesFromGenerators = exports.getFirstDatasourceProvider = exports.getFirstDatasourceName = exports.positionIsAfterFieldAndType = exports.getSymbolBeforePosition = exports.getFieldType = exports.isInsideGivenProperty = exports.isInsideQuotationMark = exports.isInsideAttribute = exports.isInsideFieldArgument = exports.getAllTypeNames = exports.getAllRelationNames = exports.extractBlockName = exports.extractFirstWord = exports.declaredNativeTypes = exports.getValuesInsideSquareBrackets = exports.getExperimentalFeaturesRange = exports.getModelOrTypeOrEnumOrViewBlock = exports.getBlockAtPosition = exports.getBlocks = exports.getWordAtPosition = exports.isFirstInsideBlock = exports.convertDocumentTextToTrimmedLineArray = exports.getCurrentLine = exports.fullDocumentRange = exports.Block = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const nativeTypes_1 = __importDefault(require("./prisma-fmt/nativeTypes"));
class Block {
    constructor(type, range, nameRange, name) {
        this.type = type;
        this.range = range;
        this.nameRange = nameRange;
        this.name = name;
    }
}
exports.Block = Block;
function fullDocumentRange(document) {
    const lastLineId = document.lineCount - 1;
    return {
        start: { line: 0, character: 0 },
        end: { line: lastLineId, character: exports.MAX_SAFE_VALUE_i32 },
    };
}
exports.fullDocumentRange = fullDocumentRange;
function getCurrentLine(document, line) {
    return document.getText({
        start: { line: line, character: 0 },
        end: { line: line, character: exports.MAX_SAFE_VALUE_i32 },
    });
}
exports.getCurrentLine = getCurrentLine;
function convertDocumentTextToTrimmedLineArray(document) {
    return Array(document.lineCount)
        .fill(0)
        .map((_, i) => getCurrentLine(document, i).trim());
}
exports.convertDocumentTextToTrimmedLineArray = convertDocumentTextToTrimmedLineArray;
function isFirstInsideBlock(position, currentLine) {
    if (currentLine.trim().length === 0) {
        return true;
    }
    const stringTilPosition = currentLine.slice(0, position.character);
    const matchArray = /\w+/.exec(stringTilPosition);
    if (!matchArray) {
        return true;
    }
    return (matchArray.length === 1 &&
        matchArray.index !== undefined &&
        stringTilPosition.length - matchArray.index - matchArray[0].length === 0);
}
exports.isFirstInsideBlock = isFirstInsideBlock;
function getWordAtPosition(document, position) {
    const currentLine = getCurrentLine(document, position.line);
    // search for the word's beginning and end
    const beginning = currentLine.slice(0, position.character + 1).search(/\S+$/);
    const end = currentLine.slice(position.character).search(/\W/);
    if (end < 0) {
        return '';
    }
    return currentLine.slice(beginning, end + position.character);
}
exports.getWordAtPosition = getWordAtPosition;
// Note: this is a generator function, which returns a Generator object.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
function* getBlocks(lines) {
    let blockName = '';
    let blockType = '';
    let blockNameRange;
    let blockStart = vscode_languageserver_1.Position.create(0, 0);
    const allowedBlockIdentifiers = ['model', 'type', 'enum', 'datasource', 'generator', 'view'];
    for (const [key, item] of lines.entries()) {
        // if start of block: `BlockType name {`
        if (allowedBlockIdentifiers.some((identifier) => item.startsWith(identifier)) && item.includes('{')) {
            if (blockType && blockNameRange) {
                // Recover from missing block end
                yield new Block(blockType, vscode_languageserver_1.Range.create(blockStart, vscode_languageserver_1.Position.create(key - 1, 0)), blockNameRange, blockName);
                blockType = '';
                blockNameRange = undefined;
            }
            const index = item.search(/\s+/);
            blockType = ~index ? item.slice(0, index) : item;
            blockName = item.slice(blockType.length, item.length - 2).trimStart();
            const startCharacter = item.length - 2 - blockName.length;
            blockName = blockName.trimEnd();
            blockNameRange = vscode_languageserver_1.Range.create(key, startCharacter, key, startCharacter + blockName.length);
            blockStart = vscode_languageserver_1.Position.create(key, 0);
            continue;
        }
        // if end of block: `}`
        if (item.startsWith('}') && blockType && blockNameRange) {
            yield new Block(blockType, vscode_languageserver_1.Range.create(blockStart, vscode_languageserver_1.Position.create(key, 1)), blockNameRange, blockName);
            blockType = '';
            blockNameRange = undefined;
        }
    }
}
exports.getBlocks = getBlocks;
function getBlockAtPosition(line, lines) {
    for (const block of getBlocks(lines)) {
        if (block.range.start.line > line) {
            return;
        }
        if (line <= block.range.end.line) {
            return block;
        }
    }
    return;
}
exports.getBlockAtPosition = getBlockAtPosition;
function getModelOrTypeOrEnumOrViewBlock(blockName, lines) {
    // get start position of block
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') && line.includes(blockName)) ||
            (line.includes('type') && line.includes(blockName)) ||
            (line.includes('enum') && line.includes(blockName)) ||
            (line.includes('view') && line.includes(blockName))) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = getBlockAtPosition(result, lines);
        if (block && block.name === blockName) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return foundBlocks[0];
}
exports.getModelOrTypeOrEnumOrViewBlock = getModelOrTypeOrEnumOrViewBlock;
// TODO can be removed? Since it was renamed to `previewFeatures` a long time ago
function getExperimentalFeaturesRange(document) {
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const experimentalFeatures = 'experimentalFeatures';
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (item.startsWith('generator') && item.includes('{')) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (reachedStartLine && item.startsWith('}')) {
            return;
        }
        if (item.startsWith(experimentalFeatures)) {
            const startIndex = getCurrentLine(document, key).indexOf(experimentalFeatures);
            return {
                start: { line: key, character: startIndex },
                end: { line: key, character: startIndex + experimentalFeatures.length },
            };
        }
    }
}
exports.getExperimentalFeaturesRange = getExperimentalFeaturesRange;
function getValuesInsideSquareBrackets(line) {
    const regexp = /\[([^\]]+)\]/;
    const matches = regexp.exec(line);
    if (!matches || !matches[1]) {
        return [];
    }
    const result = matches[1].split(',').map((name) => {
        name = name
            // trim whitespace
            .trim()
            // remove ""?
            .replace('"', '')
            .replace('"', '');
        // Remove period at the end for composite types
        if (name.endsWith('.')) {
            return name.slice(0, -1);
        }
        return name;
    });
    return result;
}
exports.getValuesInsideSquareBrackets = getValuesInsideSquareBrackets;
function declaredNativeTypes(document, onError) {
    const nativeTypes = (0, nativeTypes_1.default)(document.getText(), (errorMessage) => {
        if (onError) {
            onError(errorMessage);
        }
    });
    if (nativeTypes.length === 0) {
        return false;
    }
    return true;
}
exports.declaredNativeTypes = declaredNativeTypes;
function extractFirstWord(line) {
    return line.replace(/ .*/, '');
}
exports.extractFirstWord = extractFirstWord;
function extractBlockName(line) {
    const blockType = extractFirstWord(line);
    return line.slice(blockType.length, line.length - 1).trim();
}
exports.extractBlockName = extractBlockName;
function getAllRelationNames(lines) {
    const modelNames = [];
    for (const line of lines) {
        const modelOrEnumRegex = /^(model|enum|view)\s+(\w+)\s+{/gm;
        const result = modelOrEnumRegex.exec(line);
        if (result && result[2]) {
            modelNames.push(result[2]);
        }
    }
    return modelNames;
}
exports.getAllRelationNames = getAllRelationNames;
function getAllTypeNames(lines) {
    const typeNames = [];
    for (const line of lines) {
        const typeRegex = /^type\s+(\w+)\s+{/gm;
        const result = typeRegex.exec(line);
        if (result && result[1]) {
            typeNames.push(result[1]);
        }
    }
    return typeNames;
}
exports.getAllTypeNames = getAllTypeNames;
function isInsideFieldArgument(currentLineUntrimmed, position) {
    const symbols = '()';
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets >= 2 && numberOfOpenBrackets > numberOfClosedBrackets;
}
exports.isInsideFieldArgument = isInsideFieldArgument;
/***
 * @param symbols expects e.g. '()', '[]' or '""'
 */
function isInsideAttribute(currentLineUntrimmed, position, symbols) {
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets > numberOfClosedBrackets;
}
exports.isInsideAttribute = isInsideAttribute;
/***
 * Checks if inside e.g. "here"
 * Does not check for escaped quotation marks.
 */
function isInsideQuotationMark(currentLineUntrimmed, position) {
    let insideQuotation = false;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === '"') {
            insideQuotation = !insideQuotation;
        }
    }
    return insideQuotation;
}
exports.isInsideQuotationMark = isInsideQuotationMark;
// checks if e.g. inside 'fields' or 'references' attribute
function isInsideGivenProperty(currentLineUntrimmed, wordsBeforePosition, attributeName, position) {
    if (!isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        return false;
    }
    // We sort all attributes by their position
    const sortedAttributes = [
        {
            name: 'fields',
            position: wordsBeforePosition.findIndex((word) => word.includes('fields')),
        },
        {
            name: 'references',
            position: wordsBeforePosition.findIndex((word) => word.includes('references')),
        },
    ].sort((a, b) => (a.position < b.position ? 1 : -1));
    // If the last attribute (higher position)
    // is the one we are looking for we are in this attribute
    if (sortedAttributes[0].name === attributeName) {
        return true;
    }
    else {
        return false;
    }
}
exports.isInsideGivenProperty = isInsideGivenProperty;
function getFieldType(line) {
    const wordsInLine = line.split(/\s+/);
    if (wordsInLine.length < 2) {
        return undefined;
    }
    // Field type is in second position
    // myfield String
    const fieldType = wordsInLine[1];
    if (fieldType.length !== 0) {
        return fieldType;
    }
    return undefined;
}
exports.getFieldType = getFieldType;
function getSymbolBeforePosition(document, position) {
    return document.getText({
        start: {
            line: position.line,
            character: position.character - 1,
        },
        end: { line: position.line, character: position.character },
    });
}
exports.getSymbolBeforePosition = getSymbolBeforePosition;
function positionIsAfterFieldAndType(position, document, wordsBeforePosition) {
    const symbolBeforePosition = getSymbolBeforePosition(document, position);
    const symbolBeforeIsWhiteSpace = symbolBeforePosition.search(/\s/);
    const hasAtRelation = wordsBeforePosition.length === 2 && symbolBeforePosition === '@';
    const hasWhiteSpaceBeforePosition = wordsBeforePosition.length === 2 && symbolBeforeIsWhiteSpace !== -1;
    return wordsBeforePosition.length > 2 || hasAtRelation || hasWhiteSpaceBeforePosition;
}
exports.positionIsAfterFieldAndType = positionIsAfterFieldAndType;
function getFirstDatasourceName(lines) {
    const datasourceBlockFirstLine = lines.find((l) => l.startsWith('datasource') && l.includes('{'));
    if (!datasourceBlockFirstLine) {
        return undefined;
    }
    const indexOfBracket = datasourceBlockFirstLine.indexOf('{');
    return datasourceBlockFirstLine.slice('datasource'.length, indexOfBracket).trim();
}
exports.getFirstDatasourceName = getFirstDatasourceName;
function getFirstDatasourceProvider(lines) {
    // matches provider inside datasource in any position
    // thanks to https://regex101.com for the online scratchpad
    const result = /datasource.*\{(\n|\N)\s*(.*\n)?\n*\s*provider\s=\s(\"(.*)\")[^}]+}/.exec(lines.join('\n'));
    if (!result || !result[4]) {
        return undefined;
    }
    const datasourceProvider = result[4];
    if (typeof datasourceProvider === 'string' && datasourceProvider.length >= 1) {
        return datasourceProvider;
    }
}
exports.getFirstDatasourceProvider = getFirstDatasourceProvider;
function getAllPreviewFeaturesFromGenerators(lines) {
    // matches any `previewFeatures = [x]` in any position
    // thanks to https://regex101.com for the online scratchpad
    const previewFeaturesRegex = /previewFeatures\s=\s(\[.*\])/g;
    // we could match against all the `previewFeatures = [x]` (could be that there is more than one?)
    // var matchAll = text.matchAll(regexp)
    // for (const match of matchAll) {
    //   console.log(match);
    // }
    const result = previewFeaturesRegex.exec(lines.join('\n'));
    if (!result || !result[1]) {
        return undefined;
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const previewFeatures = JSON.parse(result[1]);
        if (Array.isArray(previewFeatures) && previewFeatures.length > 0) {
            return previewFeatures.map((it) => it.toLowerCase());
        }
    }
    catch (e) { }
    return undefined;
}
exports.getAllPreviewFeaturesFromGenerators = getAllPreviewFeaturesFromGenerators;
function getFieldsFromCurrentBlock(lines, block, position) {
    const fieldNames = [];
    for (let lineIndex = block.range.start.line + 1; lineIndex < block.range.end.line; lineIndex++) {
        if (!position || lineIndex !== position.line) {
            const line = lines[lineIndex];
            const fieldName = getFieldNameFromLine(line);
            if (fieldName) {
                fieldNames.push(fieldName);
            }
        }
    }
    return fieldNames;
}
exports.getFieldsFromCurrentBlock = getFieldsFromCurrentBlock;
// TODO a regex for \w in first position would be better?
function getFieldNameFromLine(line) {
    if (line.startsWith('//') || line.startsWith('@@')) {
        return undefined;
    }
    const firstPartOfLine = line.replace(/ .*/, '');
    return firstPartOfLine;
}
function getFieldTypesFromCurrentBlock(lines, block, position) {
    const fieldTypes = new Map();
    const fieldTypeNames = {};
    let reachedStartLine = false;
    for (const [lineIndex, line] of lines.entries()) {
        if (lineIndex === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (lineIndex === block.range.end.line) {
            break;
        }
        if (!line.startsWith('@@') && (!position || lineIndex !== position.line)) {
            const fieldType = getFieldType(line);
            if (fieldType !== undefined) {
                const existingFieldType = fieldTypes.get(fieldType);
                if (!existingFieldType) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const fieldName = getFieldNameFromLine(line);
                    fieldTypes.set(fieldType, { lineIndexes: [lineIndex], fieldName });
                    fieldTypeNames[fieldName] = fieldType;
                }
                else {
                    existingFieldType.lineIndexes.push(lineIndex);
                    fieldTypes.set(fieldType, existingFieldType);
                }
            }
        }
    }
    return { fieldTypes, fieldTypeNames };
}
exports.getFieldTypesFromCurrentBlock = getFieldTypesFromCurrentBlock;
function getCompositeTypeFieldsRecursively(lines, compositeTypeFieldNames, fieldTypesFromBlock) {
    const compositeTypeFieldName = compositeTypeFieldNames.shift();
    if (!compositeTypeFieldName) {
        return [];
    }
    const fieldTypeNames = fieldTypesFromBlock.fieldTypeNames;
    const fieldTypeName = fieldTypeNames[compositeTypeFieldName];
    if (!fieldTypeName) {
        return [];
    }
    const typeBlock = getModelOrTypeOrEnumOrViewBlock(fieldTypeName, lines);
    if (!typeBlock || typeBlock.type !== 'type') {
        return [];
    }
    // if we are not at the end of the composite type, continue recursively
    if (compositeTypeFieldNames.length) {
        return getCompositeTypeFieldsRecursively(lines, compositeTypeFieldNames, getFieldTypesFromCurrentBlock(lines, typeBlock));
    }
    else {
        return getFieldsFromCurrentBlock(lines, typeBlock);
    }
}
exports.getCompositeTypeFieldsRecursively = getCompositeTypeFieldsRecursively;
exports.MAX_SAFE_VALUE_i32 = 2147483647;
//# sourceMappingURL=util.js.map