"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleDocumentSymbol = exports.handleCodeActions = exports.handleCompletionResolveRequest = exports.handleRenameRequest = exports.handleCompletionRequest = exports.handleHoverRequest = exports.handleDocumentFormatting = exports.handleDefinitionRequest = exports.handleDiagnosticsRequest = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const util_1 = require("./util");
const format_1 = __importDefault(require("./prisma-fmt/format"));
const textDocumentCompletion_1 = __importDefault(require("./prisma-fmt/textDocumentCompletion"));
const completions_1 = require("./completion/completions");
const codeActionProvider_1 = require("./codeActionProvider");
const lint_1 = __importDefault(require("./prisma-fmt/lint"));
const renameUtil_1 = require("./rename/renameUtil");
const diagnosticsHandler_1 = require("./diagnosticsHandler");
function handleDiagnosticsRequest(document, onError) {
    const text = document.getText((0, util_1.fullDocumentRange)(document));
    const res = (0, lint_1.default)(text, (errorMessage) => {
        if (onError) {
            onError(errorMessage);
        }
    });
    const diagnostics = [];
    if (res.some((diagnostic) => diagnostic.text === "Field declarations don't require a `:`." ||
        diagnostic.text === 'Model declarations have to be indicated with the `model` keyword.')) {
        if (onError) {
            onError("You might currently be viewing a Prisma 1 datamodel which is based on the GraphQL syntax. The current Prisma Language Server doesn't support this syntax. If you are handling a Prisma 1 datamodel, please change the file extension to `.graphql` so the new Prisma Language Server does not get triggered anymore.");
        }
    }
    for (const diag of res) {
        const diagnostic = {
            range: {
                start: document.positionAt(diag.start),
                end: document.positionAt(diag.end),
            },
            message: diag.text,
            source: '',
        };
        if (diag.is_warning) {
            diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Warning;
        }
        else {
            diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Error;
        }
        diagnostics.push(diagnostic);
    }
    // TODO can be removed? Since it was renamed to `previewFeatures`
    // check for experimentalFeatures inside generator block
    // Related code in codeActionProvider.ts, around lines 185-204
    if (document.getText().includes('experimentalFeatures')) {
        const experimentalFeaturesRange = (0, util_1.getExperimentalFeaturesRange)(document);
        if (experimentalFeaturesRange) {
            diagnostics.push({
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                range: experimentalFeaturesRange,
                message: "This property has been renamed to 'previewFeatures' to better communicate what they are.",
                source: '',
            });
        }
    }
    const lines = (0, util_1.convertDocumentTextToTrimmedLineArray)(document);
    const diagnosticsForIgnore = (0, diagnosticsHandler_1.createDiagnosticsForIgnore)(lines);
    diagnostics.push(...diagnosticsForIgnore);
    return diagnostics;
}
exports.handleDiagnosticsRequest = handleDiagnosticsRequest;
/**
 * @todo Use official schema.prisma parser. This is a workaround!
 */
function handleDefinitionRequest(document, params) {
    const textDocument = params.textDocument;
    const position = params.position;
    const lines = (0, util_1.convertDocumentTextToTrimmedLineArray)(document);
    const word = (0, util_1.getWordAtPosition)(document, position);
    if (word === '') {
        return;
    }
    // get start position of block
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') && line.includes(word)) ||
            (line.includes('type') && line.includes(word)) ||
            (line.includes('enum') && line.includes(word))) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = (0, util_1.getBlockAtPosition)(result, lines);
        if (block && block.name === word && block.range.start.line === result) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return [
        {
            targetUri: textDocument.uri,
            targetRange: foundBlocks[0].range,
            targetSelectionRange: foundBlocks[0].nameRange,
        },
    ];
}
exports.handleDefinitionRequest = handleDefinitionRequest;
/**
 * This handler provides the modification to the document to be formatted.
 */
function handleDocumentFormatting(params, document, onError) {
    const formatted = (0, format_1.default)(document.getText(), params, onError);
    return [vscode_languageserver_1.TextEdit.replace((0, util_1.fullDocumentRange)(document), formatted)];
}
exports.handleDocumentFormatting = handleDocumentFormatting;
function handleHoverRequest(document, params) {
    const position = params.position;
    const lines = (0, util_1.convertDocumentTextToTrimmedLineArray)(document);
    const word = (0, util_1.getWordAtPosition)(document, position);
    if (word === '') {
        return;
    }
    const foundBlock = (0, util_1.getModelOrTypeOrEnumOrViewBlock)(word, lines);
    if (!foundBlock) {
        return;
    }
    const commentLine = foundBlock.range.start.line - 1;
    const docComments = document.getText({
        start: { line: commentLine, character: 0 },
        end: { line: commentLine, character: util_1.MAX_SAFE_VALUE_i32 },
    });
    if (docComments.startsWith('///')) {
        return {
            contents: docComments.slice(4).trim(),
        };
    }
    // TODO uncomment once https://github.com/prisma/prisma/issues/2546 is resolved!
    /*if (docComments.startsWith('//')) {
      return {
        contents: docComments.slice(3).trim(),
      }
    } */
    return;
}
exports.handleHoverRequest = handleHoverRequest;
function prismaFmtCompletions(params, document, onError) {
    const text = document.getText((0, util_1.fullDocumentRange)(document));
    const completionList = (0, textDocumentCompletion_1.default)(text, params, (errorMessage) => {
        if (onError) {
            onError(errorMessage);
        }
    });
    if (completionList.items.length === 0) {
        return undefined;
    }
    else {
        return completionList;
    }
}
function localCompletions(params, document, onError) {
    const context = params.context;
    const position = params.position;
    const lines = (0, util_1.convertDocumentTextToTrimmedLineArray)(document);
    const currentLineUntrimmed = (0, util_1.getCurrentLine)(document, position.line);
    const currentLineTillPosition = currentLineUntrimmed.slice(0, position.character - 1).trim();
    const wordsBeforePosition = currentLineTillPosition.split(/\s+/);
    const symbolBeforePosition = (0, util_1.getSymbolBeforePosition)(document, position);
    const symbolBeforePositionIsWhiteSpace = symbolBeforePosition.search(/\s/) !== -1;
    const positionIsAfterArray = wordsBeforePosition.length >= 3 && !currentLineTillPosition.includes('[') && symbolBeforePositionIsWhiteSpace;
    // datasource, generator, model, type or enum
    const foundBlock = (0, util_1.getBlockAtPosition)(position.line, lines);
    if (!foundBlock) {
        if (wordsBeforePosition.length > 1 || (wordsBeforePosition.length === 1 && symbolBeforePositionIsWhiteSpace)) {
            return;
        }
        return (0, completions_1.getSuggestionForBlockTypes)(lines);
    }
    if ((0, util_1.isFirstInsideBlock)(position, (0, util_1.getCurrentLine)(document, position.line))) {
        return (0, completions_1.getSuggestionForFirstInsideBlock)(foundBlock.type, lines, position, foundBlock);
    }
    // Completion was triggered by a triggerCharacter
    // triggerCharacters defined in src/server.ts
    if ((context === null || context === void 0 ? void 0 : context.triggerKind) === vscode_languageserver_1.CompletionTriggerKind.TriggerCharacter) {
        switch (context.triggerCharacter) {
            case '@':
                if (!(0, util_1.positionIsAfterFieldAndType)(position, document, wordsBeforePosition)) {
                    return;
                }
                return (0, completions_1.getSuggestionForFieldAttribute)(foundBlock, (0, util_1.getCurrentLine)(document, position.line), lines, wordsBeforePosition, document, onError);
            case '"':
                return (0, completions_1.getSuggestionForSupportedFields)(foundBlock.type, lines[position.line], currentLineUntrimmed, position, lines, onError);
            case '.':
                // check if inside attribute
                // Useful to complete composite types
                if (['model', 'view'].includes(foundBlock.type) && (0, util_1.isInsideAttribute)(currentLineUntrimmed, position, '()')) {
                    return (0, completions_1.getSuggestionsForInsideRoundBrackets)(currentLineUntrimmed, lines, position, foundBlock);
                }
                else {
                    return (0, completions_1.getSuggestionForNativeTypes)(foundBlock, lines, wordsBeforePosition, document, onError);
                }
        }
    }
    switch (foundBlock.type) {
        case 'model':
        case 'view':
        case 'type':
            // check if inside attribute
            if ((0, util_1.isInsideAttribute)(currentLineUntrimmed, position, '()')) {
                return (0, completions_1.getSuggestionsForInsideRoundBrackets)(currentLineUntrimmed, lines, position, foundBlock);
            }
            // check if field type
            if (!(0, util_1.positionIsAfterFieldAndType)(position, document, wordsBeforePosition)) {
                return (0, completions_1.getSuggestionsForFieldTypes)(foundBlock, lines, position, currentLineUntrimmed);
            }
            return (0, completions_1.getSuggestionForFieldAttribute)(foundBlock, lines[position.line], lines, wordsBeforePosition, document, onError);
        case 'datasource':
        case 'generator':
            if (wordsBeforePosition.length === 1 && symbolBeforePositionIsWhiteSpace) {
                return (0, completions_1.suggestEqualSymbol)(foundBlock.type);
            }
            if (currentLineTillPosition.includes('=') &&
                !currentLineTillPosition.includes(']') &&
                !positionIsAfterArray &&
                symbolBeforePosition !== ',') {
                return (0, completions_1.getSuggestionForSupportedFields)(foundBlock.type, lines[position.line], currentLineUntrimmed, position, lines, onError);
            }
            break;
        case 'enum':
            break;
    }
}
/**
 *
 * This handler provides the initial list of the completion items.
 */
function handleCompletionRequest(params, document, onError) {
    return prismaFmtCompletions(params, document, onError) || localCompletions(params, document, onError);
}
exports.handleCompletionRequest = handleCompletionRequest;
function handleRenameRequest(params, document) {
    const lines = (0, util_1.convertDocumentTextToTrimmedLineArray)(document);
    const position = params.position;
    const currentLine = lines[position.line];
    const currentBlock = (0, util_1.getBlockAtPosition)(position.line, lines);
    if (!currentBlock) {
        return;
    }
    const isBlockRename = (0, renameUtil_1.isBlockName)(position, currentBlock, lines, document, 'model') ||
        (0, renameUtil_1.isBlockName)(position, currentBlock, lines, document, 'enum') ||
        (0, renameUtil_1.isBlockName)(position, currentBlock, lines, document, 'view') ||
        (0, renameUtil_1.isBlockName)(position, currentBlock, lines, document, 'type');
    const isMappable = currentBlock.type === 'model' || currentBlock.type === 'enum' || currentBlock.type === 'view';
    const needsMap = !isBlockRename ? true : isMappable;
    const isEnumValueRename = (0, renameUtil_1.isEnumValue)(currentLine, params.position, currentBlock, document);
    const isValidFieldRename = (0, renameUtil_1.isValidFieldName)(currentLine, params.position, currentBlock, document);
    const isRelationFieldRename = isValidFieldRename && (0, renameUtil_1.isRelationField)(currentLine, lines);
    if (isBlockRename || isEnumValueRename || isValidFieldRename) {
        const edits = [];
        const currentName = (0, renameUtil_1.extractCurrentName)(currentLine, isBlockRename, isEnumValueRename, isValidFieldRename, document, params.position);
        let lineNumberOfDefinition = position.line;
        let blockOfDefinition = currentBlock;
        let lineOfDefinition = currentLine;
        if (isBlockRename) {
            // get definition of model or enum
            const matchBlockBeginning = new RegExp(`\\s*(${currentBlock.type})\\s+(${currentName})\\s*({)`, 'g');
            lineNumberOfDefinition = lines.findIndex((l) => matchBlockBeginning.test(l));
            if (lineNumberOfDefinition === -1) {
                return;
            }
            lineOfDefinition = lines[lineNumberOfDefinition];
            const definitionBlockAtPosition = (0, util_1.getBlockAtPosition)(lineNumberOfDefinition, lines);
            if (!definitionBlockAtPosition) {
                return;
            }
            blockOfDefinition = definitionBlockAtPosition;
        }
        // rename marked string
        edits.push((0, renameUtil_1.insertBasicRename)(params.newName, currentName, document, lineNumberOfDefinition));
        // check if map exists already
        if (!isRelationFieldRename &&
            !(0, renameUtil_1.mapExistsAlready)(lineOfDefinition, lines, blockOfDefinition, isBlockRename) &&
            needsMap) {
            // add map attribute
            edits.push((0, renameUtil_1.insertMapAttribute)(currentName, position, blockOfDefinition, isBlockRename));
        }
        // rename references
        if (isBlockRename) {
            edits.push(...(0, renameUtil_1.renameReferencesForModelName)(currentName, params.newName, document, lines));
        }
        else if (isEnumValueRename) {
            edits.push(...(0, renameUtil_1.renameReferencesForEnumValue)(currentName, params.newName, document, lines, blockOfDefinition.name));
        }
        else if (isValidFieldRename) {
            edits.push(...(0, renameUtil_1.renameReferencesForFieldValue)(currentName, params.newName, document, lines, blockOfDefinition, isRelationFieldRename));
        }
        (0, renameUtil_1.printLogMessage)(currentName, params.newName, isBlockRename, isValidFieldRename, isEnumValueRename, currentBlock.type);
        return {
            changes: {
                [document.uri]: edits,
            },
        };
    }
    return;
}
exports.handleRenameRequest = handleRenameRequest;
/**
 *
 * @param item This handler resolves additional information for the item selected in the completion list.
 */
function handleCompletionResolveRequest(item) {
    return item;
}
exports.handleCompletionResolveRequest = handleCompletionResolveRequest;
function handleCodeActions(params, document, onError) {
    if (!params.context.diagnostics.length) {
        return [];
    }
    return (0, codeActionProvider_1.quickFix)(document, params, onError);
}
exports.handleCodeActions = handleCodeActions;
function handleDocumentSymbol(params, document) {
    const lines = (0, util_1.convertDocumentTextToTrimmedLineArray)(document);
    return Array.from((0, util_1.getBlocks)(lines), (block) => ({
        kind: {
            model: vscode_languageserver_1.SymbolKind.Class,
            enum: vscode_languageserver_1.SymbolKind.Enum,
            type: vscode_languageserver_1.SymbolKind.Interface,
            view: vscode_languageserver_1.SymbolKind.Class,
            datasource: vscode_languageserver_1.SymbolKind.Struct,
            generator: vscode_languageserver_1.SymbolKind.Function,
        }[block.type],
        name: block.name,
        range: block.range,
        selectionRange: block.nameRange,
    }));
}
exports.handleDocumentSymbol = handleDocumentSymbol;
//# sourceMappingURL=MessageHandler.js.map