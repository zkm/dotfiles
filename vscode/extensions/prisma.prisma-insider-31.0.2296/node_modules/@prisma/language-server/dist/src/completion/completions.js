"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuggestionsForInsideRoundBrackets = exports.getSuggestionForSupportedFields = exports.suggestEqualSymbol = exports.getSuggestionForBlockTypes = exports.getSuggestionForFirstInsideBlock = exports.getSuggestionsForFieldTypes = exports.getSuggestionForFieldAttribute = exports.getSuggestionForNativeTypes = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const klona_1 = require("klona");
const completionUtils_1 = require("./completionUtils");
const listAllAvailablePreviewFeatures_1 = __importDefault(require("../prisma-fmt/listAllAvailablePreviewFeatures"));
const util_1 = require("../util");
const getSuggestionForBlockAttribute = (block, lines, suggestions) => {
    // We can filter on the datasource
    const datasourceProvider = (0, util_1.getFirstDatasourceProvider)(lines);
    // We can filter on the previewFeatures enabled
    const previewFeatures = (0, util_1.getAllPreviewFeaturesFromGenerators)(lines);
    // Full text indexes (MySQL and MongoDB)
    // https://www.prisma.io/docs/concepts/components/prisma-schema/indexes#full-text-indexes-mysql-and-mongodb
    const isFullTextAvailable = Boolean(datasourceProvider &&
        ['mysql', 'mongodb'].includes(datasourceProvider) &&
        (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('fulltextindex')));
    const isMultiSchemaAvailable = Boolean(datasourceProvider &&
        (datasourceProvider.includes('postgres') ||
            datasourceProvider.includes('cockroachdb') ||
            datasourceProvider.includes('sqlserver')) &&
        (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('multischema')));
    if (isFullTextAvailable === false) {
        // fullTextIndex is not available, we need to filter it out
        suggestions = suggestions.filter((arg) => arg.label !== '@@fulltext');
    }
    if (!isMultiSchemaAvailable) {
        suggestions = suggestions.filter((item) => item.label !== '@@schema');
    }
    return suggestions;
};
function getSuggestionForModelBlockAttribute(block, lines) {
    if (block.type !== 'model') {
        return [];
    }
    const suggestions = (0, completionUtils_1.filterSuggestionsForBlock)((0, klona_1.klona)(completionUtils_1.blockAttributes), block, lines);
    return getSuggestionForBlockAttribute(block, lines, suggestions);
}
const getSuggestionForViewBlockAttribute = (block, lines) => {
    if (block.type !== 'view') {
        return [];
    }
    const suggestions = (0, completionUtils_1.filterSuggestionsForBlock)((0, klona_1.klona)(completionUtils_1.blockAttributes), block, lines);
    return getSuggestionForBlockAttribute(block, lines, suggestions);
};
function getSuggestionForNativeTypes(foundBlock, lines, wordsBeforePosition, document, onError) {
    const activeFeatureFlag = (0, util_1.declaredNativeTypes)(document, onError);
    if (
    // TODO type? native "@db." types?
    foundBlock.type !== 'model' ||
        !activeFeatureFlag ||
        wordsBeforePosition.length < 2) {
        return undefined;
    }
    const datasourceName = (0, util_1.getFirstDatasourceName)(lines);
    if (!datasourceName || wordsBeforePosition[wordsBeforePosition.length - 1] !== `@${datasourceName}`) {
        return undefined;
    }
    // line
    const prismaType = wordsBeforePosition[1].replace('?', '').replace('[]', '');
    const suggestions = (0, completionUtils_1.getNativeTypes)(document, prismaType, onError);
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionForNativeTypes = getSuggestionForNativeTypes;
/**
 * Should suggest all field attributes for a given field
 * EX: id Int |> @id, @default, @datasourceName, ...etc
 *
 * If `@datasourceName.` |> suggests nativeTypes
 * @param block
 * @param currentLine
 * @param lines
 * @param wordsBeforePosition
 * @param document
 * @returns
 */
function getSuggestionForFieldAttribute(block, currentLine, lines, wordsBeforePosition, document, onError) {
    const fieldType = (0, util_1.getFieldType)(currentLine);
    // If we don't find a field type (e.g. String, Int...), return no suggestion
    if (!fieldType) {
        return;
    }
    let suggestions = [];
    // Because @.?
    if (wordsBeforePosition.length >= 2) {
        const datasourceName = (0, util_1.getFirstDatasourceName)(lines);
        const prismaType = wordsBeforePosition[1];
        const nativeTypeSuggestions = (0, completionUtils_1.getNativeTypes)(document, prismaType, onError);
        if (datasourceName) {
            if (!currentLine.includes(`@${datasourceName}`)) {
                suggestions.push({
                    // https://code.visualstudio.com/docs/editor/intellisense#_types-of-completions
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    label: '@' + datasourceName,
                    documentation: 'Defines a native database type that should be used for this field. See https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#native-types-mapping',
                    insertText: `@${datasourceName}$0`,
                    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                });
            }
            if (nativeTypeSuggestions.length !== 0) {
                if (
                // Check that we are not separated by a space like `@db. |`
                wordsBeforePosition[wordsBeforePosition.length - 1] === `@${datasourceName}`) {
                    suggestions.push(...nativeTypeSuggestions);
                    return {
                        items: suggestions,
                        isIncomplete: false,
                    };
                }
            }
        }
    }
    suggestions.push(...completionUtils_1.fieldAttributes);
    const modelOrTypeOrEnum = (0, util_1.getModelOrTypeOrEnumOrViewBlock)(fieldType, lines);
    suggestions = (0, completionUtils_1.filterSuggestionsForLine)(suggestions, currentLine, fieldType, modelOrTypeOrEnum === null || modelOrTypeOrEnum === void 0 ? void 0 : modelOrTypeOrEnum.type);
    suggestions = (0, completionUtils_1.filterSuggestionsForBlock)(suggestions, block, lines);
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFieldAttribute = getSuggestionForFieldAttribute;
function getSuggestionsForFieldTypes(foundBlock, lines, position, currentLineUntrimmed) {
    const suggestions = [];
    const datasourceProvider = (0, util_1.getFirstDatasourceProvider)(lines);
    // MongoDB doesn't support Decimal
    if (datasourceProvider === 'mongodb') {
        suggestions.push(...completionUtils_1.corePrimitiveTypes.filter((s) => s.label !== 'Decimal'));
    }
    else {
        suggestions.push(...completionUtils_1.corePrimitiveTypes);
    }
    if (foundBlock instanceof util_1.Block) {
        // get all model names
        const modelNames = (0, util_1.getAllRelationNames)(lines);
        suggestions.push(...(0, completionUtils_1.toCompletionItems)(modelNames, vscode_languageserver_1.CompletionItemKind.Reference));
    }
    const wordsBeforePosition = currentLineUntrimmed.slice(0, position.character).split(' ');
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const completeSuggestions = suggestions.filter((s) => s.label.length === wordBeforePosition.length);
    if (completeSuggestions.length !== 0) {
        for (const sugg of completeSuggestions) {
            suggestions.push({
                label: `${sugg.label}?`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            }, {
                label: `${sugg.label}[]`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            });
        }
    }
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionsForFieldTypes = getSuggestionsForFieldTypes;
function getSuggestionForGeneratorField(block, lines, position) {
    // create deep copy
    const suggestions = (0, klona_1.klona)(completionUtils_1.supportedGeneratorFields);
    const labels = (0, completionUtils_1.removeInvalidFieldSuggestions)(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
/**
 * gets suggestions for block type
 */
function getSuggestionForFirstInsideBlock(blockType, lines, position, block) {
    let suggestions = [];
    switch (blockType) {
        case 'generator':
            suggestions = getSuggestionForGeneratorField(block, lines, position);
            break;
        case 'model':
            suggestions = getSuggestionForModelBlockAttribute(block, lines);
            break;
        case 'view':
            suggestions = getSuggestionForViewBlockAttribute(block, lines);
            break;
        case 'type':
            // No suggestions
            break;
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFirstInsideBlock = getSuggestionForFirstInsideBlock;
/**
 * Returns the currently available _blocks_ for completion.
 * Currently available: Generator, Datasource, Model, Enum, View
 * @param lines
 * @returns the list of block suggestions
 */
function getSuggestionForBlockTypes(lines) {
    // create deep copy
    let suggestions = (0, klona_1.klona)(completionUtils_1.allowedBlockTypes);
    const datasourceProvider = (0, util_1.getFirstDatasourceProvider)(lines);
    const previewFeatures = (0, util_1.getAllPreviewFeaturesFromGenerators)(lines);
    const isEnumAvailable = Boolean(!(datasourceProvider === null || datasourceProvider === void 0 ? void 0 : datasourceProvider.includes('sqlite')));
    const isViewAvailable = Boolean(previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.includes('views'));
    const isTypeAvailable = Boolean(datasourceProvider === null || datasourceProvider === void 0 ? void 0 : datasourceProvider.includes('mongodb'));
    if (!isEnumAvailable) {
        suggestions = suggestions.filter((item) => item.label !== 'enum');
    }
    if (!isViewAvailable) {
        suggestions = suggestions.filter((item) => item.label !== 'view');
    }
    if (!isTypeAvailable) {
        suggestions = suggestions.filter((item) => item.label !== 'type');
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForBlockTypes = getSuggestionForBlockTypes;
function suggestEqualSymbol(blockType) {
    if (!(blockType == 'datasource' || blockType == 'generator')) {
        return;
    }
    const equalSymbol = { label: '=' };
    return {
        items: [equalSymbol],
        isIncomplete: false,
    };
}
exports.suggestEqualSymbol = suggestEqualSymbol;
// Suggest fields for a BlockType
function getSuggestionForSupportedFields(blockType, currentLine, currentLineUntrimmed, position, lines, onError) {
    let suggestions = [];
    const isInsideQuotation = (0, util_1.isInsideQuotationMark)(currentLineUntrimmed, position);
    // We can filter on the datasource
    const datasourceProvider = (0, util_1.getFirstDatasourceProvider)(lines);
    // We can filter on the previewFeatures enabled
    // const previewFeatures = getAllPreviewFeaturesFromGenerators(lines)
    switch (blockType) {
        case 'generator':
            // provider
            if (currentLine.startsWith('provider')) {
                const providers = completionUtils_1.generatorProviders;
                if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtils_1.generatorProviderArguments,
                        isIncomplete: true,
                    };
                }
            }
            // previewFeatures
            else if (currentLine.startsWith('previewFeatures')) {
                const generatorPreviewFeatures = (0, listAllAvailablePreviewFeatures_1.default)(onError);
                if (generatorPreviewFeatures.length > 0) {
                    return (0, completionUtils_1.handlePreviewFeatures)(generatorPreviewFeatures, position, currentLineUntrimmed, isInsideQuotation);
                }
            }
            // engineType
            else if (currentLine.startsWith('engineType')) {
                const engineTypesCompletion = completionUtils_1.engineTypes;
                if (isInsideQuotation) {
                    return {
                        items: engineTypesCompletion,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtils_1.engineTypeArguments,
                        isIncomplete: true,
                    };
                }
            }
            break;
        case 'datasource':
            // provider
            if (currentLine.startsWith('provider')) {
                const providers = completionUtils_1.dataSourceProviders;
                if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtils_1.dataSourceProviderArguments,
                        isIncomplete: true,
                    };
                }
            }
            // url or shadowDatabaseUrl or directUrl
            else if (currentLine.startsWith('url') ||
                currentLine.startsWith('shadowDatabaseUrl') ||
                currentLine.startsWith('directUrl')) {
                // check if inside env
                if ((0, util_1.isInsideAttribute)(currentLineUntrimmed, position, '()')) {
                    if (currentLine.startsWith('url')) {
                        suggestions = ['DATABASE_URL'];
                    }
                    else if (currentLine.startsWith('shadowDatabaseUrl')) {
                        suggestions = ['SHADOW_DATABASE_URL'];
                    }
                    else if (currentLine.startsWith('directUrl')) {
                        suggestions = ['DIRECT_URL'];
                    }
                }
            }
            // `relationMode` can only be set for SQL databases
            else if (currentLine.startsWith('relationMode') && datasourceProvider !== 'mongodb') {
                const relationModeValuesSuggestion = completionUtils_1.relationModeValues;
                // values inside quotes `"value"`
                const relationModeValuesSuggestionWithQuotes = (0, klona_1.klona)(relationModeValuesSuggestion).map((suggestion) => {
                    suggestion.label = `"${suggestion.label}"`;
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    suggestion.insertText = `"${suggestion.insertText}"`;
                    return suggestion;
                });
                if (isInsideQuotation) {
                    return {
                        items: relationModeValuesSuggestion,
                        isIncomplete: false,
                    };
                }
                // If line ends with `"`, a value is already set.
                else if (!currentLine.endsWith('"')) {
                    return {
                        items: relationModeValuesSuggestionWithQuotes,
                        isIncomplete: false,
                    };
                }
            }
    }
    return {
        items: (0, completionUtils_1.toCompletionItems)(suggestions, vscode_languageserver_1.CompletionItemKind.Constant),
        isIncomplete: false,
    };
}
exports.getSuggestionForSupportedFields = getSuggestionForSupportedFields;
function getDefaultValues({ currentLine, lines, wordsBeforePosition, }) {
    const suggestions = [];
    const datasourceProvider = (0, util_1.getFirstDatasourceProvider)(lines);
    // Completions for sequence(|)
    if (datasourceProvider === 'cockroachdb') {
        if (wordsBeforePosition.some((a) => a.includes('sequence('))) {
            const sequenceProperties = ['virtual', 'minValue', 'maxValue', 'cache', 'increment', 'start'];
            // No suggestions if virtual is present
            if (currentLine.includes('virtual')) {
                return suggestions;
            }
            // Only suggests if empty
            if (!sequenceProperties.some((it) => currentLine.includes(it))) {
                suggestions.push({
                    label: 'virtual',
                    insertText: 'virtual',
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    documentation: 'Virtual sequences are sequences that do not generate monotonically increasing values and instead produce values like those generated by the built-in function unique_rowid(). They are intended for use in combination with SERIAL-typed columns.',
                });
            }
            if (!currentLine.includes('minValue')) {
                suggestions.push({
                    label: 'minValue',
                    insertText: 'minValue: $0',
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    documentation: 'The new minimum value of the sequence.',
                });
            }
            if (!currentLine.includes('maxValue')) {
                suggestions.push({
                    label: 'maxValue',
                    insertText: 'maxValue: $0',
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    documentation: 'The new maximum value of the sequence.',
                });
            }
            if (!currentLine.includes('cache')) {
                suggestions.push({
                    label: 'cache',
                    insertText: 'cache: $0',
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    documentation: 'The number of sequence values to cache in memory for reuse in the session. A cache size of 1 means that there is no cache, and cache sizes of less than 1 are not valid.',
                });
            }
            if (!currentLine.includes('increment')) {
                suggestions.push({
                    label: 'increment',
                    insertText: 'increment: $0',
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    documentation: 'The new value by which the sequence is incremented. A negative number creates a descending sequence. A positive number creates an ascending sequence.',
                });
            }
            if (!currentLine.includes('start')) {
                suggestions.push({
                    label: 'start',
                    insertText: 'start: $0',
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    documentation: 'The value the sequence starts at if you RESTART or if the sequence hits the MAXVALUE and CYCLE is set.',
                });
            }
            return suggestions;
        }
    }
    // MongoDB only
    if (datasourceProvider === 'mongodb') {
        suggestions.push({
            label: 'auto()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            documentation: 'Represents default values that are automatically generated by the database.',
            insertText: 'auto()',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
        });
    }
    else {
        suggestions.push({
            label: 'dbgenerated("")',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            documentation: 'The SQL definition of the default value which is generated by the database. This is not validated by Prisma.',
            insertText: 'dbgenerated("$0")',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
        });
    }
    const fieldType = (0, util_1.getFieldType)(currentLine);
    // If we don't find a field type (e.g. String, Int...), return no suggestion
    if (!fieldType) {
        return [];
    }
    switch (fieldType) {
        case 'BigInt':
        case 'Int':
            if (datasourceProvider === 'cockroachdb') {
                suggestions.push({
                    label: 'sequence()',
                    kind: vscode_languageserver_1.CompletionItemKind.Function,
                    documentation: 'Create a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.',
                });
                if (fieldType === 'Int') {
                    // @default(autoincrement()) is only supported on BigInt fields for cockroachdb.
                    break;
                }
            }
            suggestions.push({
                label: 'autoincrement()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: 'Create a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.',
            });
            break;
        case 'DateTime':
            suggestions.push({
                label: 'now()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Set a timestamp of the time when a record is created.',
                },
            });
            break;
        case 'String':
            suggestions.push({
                label: 'uuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) spec.',
                },
            }, {
                label: 'cuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [cuid](https://github.com/ericelliott/cuid) spec.',
                },
            });
            break;
        case 'Boolean':
            suggestions.push({ label: 'true', kind: vscode_languageserver_1.CompletionItemKind.Value }, { label: 'false', kind: vscode_languageserver_1.CompletionItemKind.Value });
            break;
    }
    const isScalarList = fieldType.endsWith('[]');
    if (isScalarList) {
        suggestions.unshift({
            label: '[]',
            insertText: '[$0]',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            documentation: 'Set a default value on the list field',
            kind: vscode_languageserver_1.CompletionItemKind.Value,
        });
    }
    const modelOrEnum = (0, util_1.getModelOrTypeOrEnumOrViewBlock)(fieldType, lines);
    if (modelOrEnum && modelOrEnum.type === 'enum') {
        // get fields from enum block for suggestions
        const values = (0, util_1.getFieldsFromCurrentBlock)(lines, modelOrEnum);
        values.forEach((v) => suggestions.push({ label: v, kind: vscode_languageserver_1.CompletionItemKind.Value }));
    }
    return suggestions;
}
function getSuggestionsForAttribute({ attribute, wordsBeforePosition, untrimmedCurrentLine, lines, block, position, }) {
    const firstWordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const secondWordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 2];
    const wordBeforePosition = firstWordBeforePosition === '' ? secondWordBeforePosition : firstWordBeforePosition;
    let suggestions = [];
    // We can filter on the datasource
    const datasourceProvider = (0, util_1.getFirstDatasourceProvider)(lines);
    // We can filter on the previewFeatures enabled
    const previewFeatures = (0, util_1.getAllPreviewFeaturesFromGenerators)(lines);
    if (attribute === '@relation') {
        if (datasourceProvider === 'mongodb') {
            suggestions = completionUtils_1.relationArguments.filter((arg) => arg.label !== 'map' && arg.label !== 'onDelete' && arg.label !== 'onUpdate');
        }
        else {
            suggestions = completionUtils_1.relationArguments;
        }
        // If we are right after @relation(
        if (wordBeforePosition.includes('@relation')) {
            return {
                items: suggestions,
                isIncomplete: false,
            };
        }
        // TODO check fields with [] shortcut
        if ((0, util_1.isInsideGivenProperty)(untrimmedCurrentLine, wordsBeforePosition, 'fields', position)) {
            return {
                items: (0, completionUtils_1.toCompletionItems)((0, util_1.getFieldsFromCurrentBlock)(lines, block, position), vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
        if ((0, util_1.isInsideGivenProperty)(untrimmedCurrentLine, wordsBeforePosition, 'references', position)) {
            // Get the name by potentially removing ? and [] from Foo? or Foo[]
            const referencedModelName = wordsBeforePosition[1].replace('?', '').replace('[]', '');
            const referencedBlock = (0, util_1.getModelOrTypeOrEnumOrViewBlock)(referencedModelName, lines);
            // referenced model does not exist
            // TODO type?
            if (!referencedBlock || referencedBlock.type !== 'model') {
                return;
            }
            return {
                items: (0, completionUtils_1.toCompletionItems)((0, util_1.getFieldsFromCurrentBlock)(lines, referencedBlock), vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
    }
    else {
        // @id, @unique
        // @@id, @@unique, @@index, @@fulltext
        // The length argument is available on MySQL only on the
        // @id, @@id, @unique, @@unique and @@index fields.
        // The sort argument is available for all databases on the
        // @unique, @@unique and @@index fields.
        // Additionally, SQL Server also allows it on @id and @@id.
        let attribute = undefined;
        if (wordsBeforePosition.some((a) => a.includes('@@id'))) {
            attribute = '@@id';
        }
        else if (wordsBeforePosition.some((a) => a.includes('@id'))) {
            attribute = '@id';
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@unique'))) {
            attribute = '@@unique';
        }
        else if (wordsBeforePosition.some((a) => a.includes('@unique'))) {
            attribute = '@unique';
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@index'))) {
            attribute = '@@index';
        }
        else if (wordsBeforePosition.some((a) => a.includes('@@fulltext'))) {
            attribute = '@@fulltext';
        }
        /**
         * inside []
         * suggest composite types for MongoDB
         * suggest fields and extendedIndexes arguments (sort / length)
         *
         * Examples
         * field attribute: slug String @unique(sort: Desc, length: 42) @db.VarChar(3000)
         * block attribute: @@id([title(length: 100, sort: Desc), abstract(length: 10)])
         */
        if (attribute && attribute !== '@@fulltext' && (0, util_1.isInsideAttribute)(untrimmedCurrentLine, position, '[]')) {
            if ((0, util_1.isInsideFieldArgument)(untrimmedCurrentLine, position)) {
                // extendedIndexes
                const items = [];
                // https://www.notion.so/prismaio/Proposal-More-PostgreSQL-index-types-GiST-GIN-SP-GiST-and-BRIN-e27ef762ee4846a9a282eec1a5129270
                if (datasourceProvider === 'postgresql' && attribute === '@@index') {
                    items.push({
                        label: 'ops',
                        insertText: 'ops: $0',
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                        kind: vscode_languageserver_1.CompletionItemKind.Property,
                        documentation: 'Specify the operator class for an indexed field.',
                    });
                }
                items.push(...(0, completionUtils_1.filterSortLengthBasedOnInput)(attribute, previewFeatures, datasourceProvider, wordBeforePosition, completionUtils_1.sortLengthProperties));
                return {
                    items,
                    isIncomplete: false,
                };
            }
            const fieldsFromLine = (0, util_1.getValuesInsideSquareBrackets)(untrimmedCurrentLine);
            /*
             * MongoDB composite type fields, see https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#composite-type-unique-constraints
             * Examples
             * @@unique([address.|]) or @@unique(fields: [address.|])
             * @@index([address.|]) or @@index(fields: [address.|])
             */
            if (datasourceProvider === 'mongodb' && fieldsFromLine && firstWordBeforePosition.endsWith('.')) {
                const getFieldName = (text) => {
                    const [_, __, value] = new RegExp(/(.*\[)?(.+)/).exec(text) || [];
                    let name = value;
                    // Example for `@@index([email,address.|])` when there is no space between fields
                    if (name === null || name === void 0 ? void 0 : name.includes(',')) {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        name = name.split(',').pop();
                    }
                    // Remove . to only get the name
                    if (name === null || name === void 0 ? void 0 : name.endsWith('.')) {
                        name = name.slice(0, -1);
                    }
                    return name;
                };
                const currentFieldName = getFieldName(firstWordBeforePosition);
                if (!currentFieldName) {
                    return {
                        isIncomplete: false,
                        items: [],
                    };
                }
                const currentCompositeAsArray = currentFieldName.split('.');
                const fieldTypesFromCurrentBlock = (0, util_1.getFieldTypesFromCurrentBlock)(lines, block);
                const fields = (0, util_1.getCompositeTypeFieldsRecursively)(lines, currentCompositeAsArray, fieldTypesFromCurrentBlock);
                return {
                    items: (0, completionUtils_1.toCompletionItems)(fields, vscode_languageserver_1.CompletionItemKind.Field),
                    isIncomplete: false,
                };
            }
            let fieldsFromCurrentBlock = (0, util_1.getFieldsFromCurrentBlock)(lines, block, position);
            if (fieldsFromLine.length > 0) {
                // If we are in a composite type, exit here, to not pollute results with first level fields
                if (firstWordBeforePosition.includes('.')) {
                    return {
                        isIncomplete: false,
                        items: [],
                    };
                }
                // Remove items already used
                fieldsFromCurrentBlock = fieldsFromCurrentBlock.filter((s) => !fieldsFromLine.includes(s));
                // Return fields
                // `onCompletionResolve` will take care of filtering the partial matches
                if (firstWordBeforePosition !== '' &&
                    !firstWordBeforePosition.endsWith(',') &&
                    !firstWordBeforePosition.endsWith(', ')) {
                    return {
                        items: (0, completionUtils_1.toCompletionItems)(fieldsFromCurrentBlock, vscode_languageserver_1.CompletionItemKind.Field),
                        isIncomplete: false,
                    };
                }
            }
            return {
                items: (0, completionUtils_1.toCompletionItems)(fieldsFromCurrentBlock, vscode_languageserver_1.CompletionItemKind.Field),
                isIncomplete: false,
            };
        }
        // "@@" block attributes
        let blockAtrributeArguments = [];
        if (attribute === '@@unique') {
            blockAtrributeArguments = (0, completionUtils_1.givenBlockAttributeParams)({
                blockAttribute: '@@unique',
                wordBeforePosition,
                datasourceProvider,
                previewFeatures,
            });
        }
        else if (attribute === '@@id') {
            blockAtrributeArguments = (0, completionUtils_1.givenBlockAttributeParams)({
                blockAttribute: '@@id',
                wordBeforePosition,
                datasourceProvider,
                previewFeatures,
            });
        }
        else if (attribute === '@@index') {
            blockAtrributeArguments = (0, completionUtils_1.givenBlockAttributeParams)({
                blockAttribute: '@@index',
                wordBeforePosition,
                datasourceProvider,
                previewFeatures,
            });
        }
        else if (attribute === '@@fulltext') {
            blockAtrributeArguments = (0, completionUtils_1.givenBlockAttributeParams)({
                blockAttribute: '@@fulltext',
                wordBeforePosition,
                datasourceProvider,
                previewFeatures,
            });
        }
        if (blockAtrributeArguments.length) {
            suggestions = blockAtrributeArguments;
        }
        else {
            // "@" field attributes
            let fieldAtrributeArguments = [];
            if (attribute === '@unique') {
                fieldAtrributeArguments = (0, completionUtils_1.givenFieldAttributeParams)('@unique', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            else if (attribute === '@id') {
                fieldAtrributeArguments = (0, completionUtils_1.givenFieldAttributeParams)('@id', previewFeatures, datasourceProvider, wordBeforePosition);
            }
            suggestions = fieldAtrributeArguments;
        }
    }
    // Check which attributes are already present
    // so we can filter them out from the suggestions
    const attributesFound = new Set();
    for (const word of wordsBeforePosition) {
        if (word.includes('references')) {
            attributesFound.add('references');
        }
        if (word.includes('fields')) {
            attributesFound.add('fields');
        }
        if (word.includes('onUpdate')) {
            attributesFound.add('onUpdate');
        }
        if (word.includes('onDelete')) {
            attributesFound.add('onDelete');
        }
        if (word.includes('map')) {
            attributesFound.add('map');
        }
        if (word.includes('name') || /".*"/.exec(word)) {
            attributesFound.add('name');
            attributesFound.add('""');
        }
        if (word.includes('type')) {
            attributesFound.add('type');
        }
    }
    // now filter them out of the suggestions as they are already present
    const filteredSuggestions = suggestions.reduce((accumulator, sugg) => {
        let suggestionMatch = false;
        for (const attribute of attributesFound) {
            if (sugg.label.includes(attribute)) {
                suggestionMatch = true;
            }
        }
        if (!suggestionMatch) {
            accumulator.push(sugg);
        }
        return accumulator;
    }, []);
    // nothing to present any more, return
    if (filteredSuggestions.length === 0) {
        return;
    }
    return {
        items: filteredSuggestions,
        isIncomplete: false,
    };
}
function getSuggestionsForInsideRoundBrackets(untrimmedCurrentLine, lines, position, block) {
    const wordsBeforePosition = untrimmedCurrentLine.slice(0, position.character).trimLeft().split(/\s+/);
    if (wordsBeforePosition.some((a) => a.includes('@default'))) {
        return {
            items: getDefaultValues({
                currentLine: lines[position.line],
                lines,
                wordsBeforePosition,
            }),
            isIncomplete: false,
        };
    }
    else if (wordsBeforePosition.some((a) => a.includes('@relation'))) {
        return getSuggestionsForAttribute({
            attribute: '@relation',
            wordsBeforePosition,
            untrimmedCurrentLine,
            lines,
            // document,
            block,
            position,
        });
    }
    else if (
    // matches
    // @id, @unique
    // @@id, @@unique, @@index, @@fulltext
    wordsBeforePosition.some((a) => a.includes('@unique') || a.includes('@id') || a.includes('@@index') || a.includes('@@fulltext'))) {
        return getSuggestionsForAttribute({
            wordsBeforePosition,
            untrimmedCurrentLine,
            lines,
            // document,
            block,
            position,
        });
    }
    else {
        return {
            items: (0, completionUtils_1.toCompletionItems)([], vscode_languageserver_1.CompletionItemKind.Field),
            isIncomplete: false,
        };
    }
}
exports.getSuggestionsForInsideRoundBrackets = getSuggestionsForInsideRoundBrackets;
//# sourceMappingURL=completions.js.map