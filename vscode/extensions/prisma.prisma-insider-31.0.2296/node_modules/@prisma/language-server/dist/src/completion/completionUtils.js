"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNativeTypes = exports.handlePreviewFeatures = exports.removeInvalidFieldSuggestions = exports.filterSuggestionsForLine = exports.filterSuggestionsForBlock = exports.toCompletionItems = exports.previewFeaturesArguments = exports.engineTypeArguments = exports.engineTypes = exports.generatorProviderArguments = exports.generatorProviders = exports.dataSourceProviderArguments = exports.dataSourceProviders = exports.relationArguments = exports.sortLengthProperties = exports.fieldAttributes = exports.filterSortLengthBasedOnInput = exports.givenFieldAttributeParams = exports.sqlServerClusteredValuesCompletionItems = exports.sortValuesCompletionItems = exports.blockAttributes = exports.givenBlockAttributeParams = exports.supportedGeneratorFields = exports.relationModeValues = exports.allowedBlockTypes = exports.corePrimitiveTypes = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const completions = __importStar(require("./completions.json"));
const nativeTypes_1 = __importDefault(require("../prisma-fmt/nativeTypes"));
const util_1 = require("../util");
// Docs about CompletionItem
// https://code.visualstudio.com/api/references/vscode-api#CompletionItem
/**
 * Converts a json object containing labels and documentations to CompletionItems.
 */
function convertToCompletionItems(completionItems, itemKind) {
    const result = [];
    for (const item of completionItems) {
        let documentationString = undefined;
        if (item.documentation) {
            // If a "fullSignature" is provided, we want to show it in the completion item
            const documentationWithSignature = item.fullSignature && item.documentation
                ? ['```prisma', item.fullSignature, '```', '___', item.documentation].join('\n')
                : undefined;
            // If not we only show the documentation
            documentationString = documentationWithSignature ? documentationWithSignature : item.documentation;
        }
        result.push({
            label: item.label,
            kind: itemKind,
            insertText: item.insertText,
            insertTextFormat: item.insertText ? vscode_languageserver_1.InsertTextFormat.Snippet : vscode_languageserver_1.InsertTextFormat.PlainText,
            insertTextMode: item.insertText ? vscode_languageserver_1.InsertTextMode.adjustIndentation : undefined,
            documentation: documentationString ? { kind: vscode_languageserver_1.MarkupKind.Markdown, value: documentationString } : undefined,
        });
    }
    return result;
}
/**
 * Converts a json object containing attributes including function signatures to CompletionItems.
 */
function convertAttributesToCompletionItems(completionItems, itemKind) {
    const result = [];
    for (const item of completionItems) {
        const docComment = ['```prisma', item.fullSignature, '```', '___', item.documentation];
        for (const param of item.params) {
            docComment.push('', '_@param_ ' + param.label + ' ' + param.documentation);
        }
        result.push({
            label: item.label,
            kind: itemKind,
            insertText: item.insertText,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            insertTextMode: item.insertText ? vscode_languageserver_1.InsertTextMode.adjustIndentation : undefined,
            documentation: {
                kind: vscode_languageserver_1.MarkupKind.Markdown,
                value: docComment.join('\n'),
            },
        });
    }
    return result;
}
exports.corePrimitiveTypes = convertToCompletionItems(completions.primitiveTypes, vscode_languageserver_1.CompletionItemKind.TypeParameter);
exports.allowedBlockTypes = convertToCompletionItems(completions.blockTypes, vscode_languageserver_1.CompletionItemKind.Class);
exports.relationModeValues = convertToCompletionItems(completions.relationModeValues, vscode_languageserver_1.CompletionItemKind.Field);
exports.supportedGeneratorFields = convertToCompletionItems(completions.generatorFields, vscode_languageserver_1.CompletionItemKind.Field);
function givenBlockAttributeParams({ blockAttribute, wordBeforePosition, datasourceProvider, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
previewFeatures, }) {
    const items = convertToCompletionItems(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    completions.blockAttributes.find((item) => item.label.includes(blockAttribute)).params, vscode_languageserver_1.CompletionItemKind.Property);
    // SQL Server only, suggest clustered
    if (datasourceProvider === 'sqlserver' && blockAttribute !== '@@fulltext') {
        // Auto completion for SQL Server only, clustered: true | false
        if (wordBeforePosition.includes('clustered:')) {
            return exports.sqlServerClusteredValuesCompletionItems;
        }
        else {
            // add clustered to suggestions
            items.push({
                label: 'clustered',
                insertText: 'clustered: $0',
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                kind: vscode_languageserver_1.CompletionItemKind.Property,
                documentation: 'An index, unique constraint or primary key can be created as clustered or non-clustered; altering the storage and retrieve behavior of the index.',
            });
        }
    }
    // PostgreSQL only, suggest type
    else if (blockAttribute === '@@index' &&
        datasourceProvider &&
        ['postgresql', 'postgres'].includes(datasourceProvider)) {
        // TODO figure out if we need to add cockroachdb provider here
        // The type argument is only available for PostgreSQL on @@index
        items.push({
            label: 'type',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
            insertText: 'type: $0',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            insertTextMode: vscode_languageserver_1.InsertTextMode.adjustIndentation,
            documentation: {
                kind: 'markdown',
                value: 'Defines the access type of indexes: BTree (default) or Hash.',
            },
        });
    }
    return items;
}
exports.givenBlockAttributeParams = givenBlockAttributeParams;
exports.blockAttributes = convertAttributesToCompletionItems(completions.blockAttributes, vscode_languageserver_1.CompletionItemKind.Property);
exports.sortValuesCompletionItems = [
    {
        label: 'Asc',
        kind: vscode_languageserver_1.CompletionItemKind.Enum,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'Ascending',
        },
    },
    {
        label: 'Desc',
        kind: vscode_languageserver_1.CompletionItemKind.Enum,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'Descending',
        },
    },
];
exports.sqlServerClusteredValuesCompletionItems = [
    {
        label: 'true',
        kind: vscode_languageserver_1.CompletionItemKind.Value,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'CLUSTERED',
        },
    },
    {
        label: 'false',
        kind: vscode_languageserver_1.CompletionItemKind.Value,
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        documentation: {
            kind: 'markdown',
            value: 'NONCLUSTERED',
        },
    },
];
function givenFieldAttributeParams(fieldAttribute, previewFeatures, datasourceProvider, wordBeforePosition) {
    const items = convertToCompletionItems(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    completions.fieldAttributes.find((item) => item.label.includes(fieldAttribute)).params, vscode_languageserver_1.CompletionItemKind.Property);
    const completionItems = filterSortLengthBasedOnInput(fieldAttribute, previewFeatures, datasourceProvider, wordBeforePosition, items);
    if (datasourceProvider === 'sqlserver') {
        // Auto completion for SQL Server only, clustered: true | false
        if (wordBeforePosition.includes('clustered:')) {
            return exports.sqlServerClusteredValuesCompletionItems;
        }
        // add clustered propery to completion items
        completionItems.push({
            label: 'clustered',
            insertText: 'clustered: $0',
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            kind: vscode_languageserver_1.CompletionItemKind.Property,
            documentation: 'An index, unique constraint or primary key can be created as clustered or non-clustered; altering the storage and retrieve behavior of the index.',
        });
    }
    return completionItems;
}
exports.givenFieldAttributeParams = givenFieldAttributeParams;
function filterSortLengthBasedOnInput(attribute, previewFeatures, datasourceProvider, wordBeforePosition, items) {
    /*
     * 1 - Autocomplete values
     */
    // Auto completion for sort: Desc | Asc
    // includes because `@unique(sort: |)` means wordBeforePosition = '@unique(sort:'
    if (wordBeforePosition.includes('sort:')) {
        return exports.sortValuesCompletionItems;
    }
    else {
        /*
         * 2 - Autocomplete properties
         */
        // The length argument is available on MySQL only on the
        // @id, @@id, @unique, @@unique and @@index fields.
        // The sort argument is available for all databases on the
        // @unique, @@unique and @@index fields.
        // Additionally, SQL Server also allows it on @id and @@id.
        // Which translates too
        // - `length` argument for `@id`, `@@id`, `@unique`, `@@unique` and `@@index` (MySQL only)
        // - Note that on the `@@` the argument is on available a field - not on the top level attribute
        // - `sort` argument for `@unique`, `@@unique` and `@@index` (Additionally `@id` and `@@id` for SQL Server)
        if (datasourceProvider === 'mysql') {
            if (['@unique', '@@unique', '@@index'].includes(attribute)) {
                return items;
            }
            else {
                // filter sort out
                return items.filter((arg) => arg.label !== 'sort');
            }
        }
        else if (datasourceProvider === 'sqlserver') {
            if (['@unique', '@@unique', '@@index', '@id', '@@id'].includes(attribute)) {
                // only filter length out
                return items.filter((arg) => arg.label !== 'length');
            }
            else {
                // filter length and sort out
                return items.filter((arg) => arg.label !== 'length' && arg.label !== 'sort');
            }
        }
        else {
            if (['@unique', '@@unique', '@@index'].includes(attribute)) {
                // only filter length out
                return items.filter((arg) => arg.label !== 'length');
            }
            else {
                // filter length and sort out
                return items.filter((arg) => arg.label !== 'length' && arg.label !== 'sort');
            }
        }
    }
}
exports.filterSortLengthBasedOnInput = filterSortLengthBasedOnInput;
exports.fieldAttributes = convertAttributesToCompletionItems(completions.fieldAttributes, vscode_languageserver_1.CompletionItemKind.Property);
exports.sortLengthProperties = convertToCompletionItems(
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
completions.fieldAttributes
    .find((item) => item.label === '@unique')
    .params.filter((item) => item.label === 'length' || item.label === 'sort'), vscode_languageserver_1.CompletionItemKind.Property);
exports.relationArguments = convertAttributesToCompletionItems(completions.relationArguments, vscode_languageserver_1.CompletionItemKind.Property);
exports.dataSourceProviders = convertToCompletionItems(completions.datasourceProviders, vscode_languageserver_1.CompletionItemKind.Constant);
exports.dataSourceProviderArguments = convertToCompletionItems(completions.datasourceProviderArguments, vscode_languageserver_1.CompletionItemKind.Property);
// generator.provider
exports.generatorProviders = convertToCompletionItems(completions.generatorProviders, vscode_languageserver_1.CompletionItemKind.Constant);
exports.generatorProviderArguments = convertToCompletionItems(completions.generatorProviderArguments, vscode_languageserver_1.CompletionItemKind.Property);
// generator.engineType
exports.engineTypes = convertToCompletionItems(completions.engineTypes, vscode_languageserver_1.CompletionItemKind.Constant);
exports.engineTypeArguments = convertToCompletionItems(completions.engineTypeArguments, vscode_languageserver_1.CompletionItemKind.Property);
// generator.previewFeatures
exports.previewFeaturesArguments = convertToCompletionItems(completions.previewFeaturesArguments, vscode_languageserver_1.CompletionItemKind.Property);
function toCompletionItems(allowedTypes, kind) {
    return allowedTypes.map((label) => ({ label, kind }));
}
exports.toCompletionItems = toCompletionItems;
/**
 * Removes all block attribute suggestions that are invalid in this context.
 * E.g. `@@id()` when already used should not be in the suggestions.
 */
function filterSuggestionsForBlock(suggestions, block, lines) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.range.end.line) {
            break;
        }
        // Ignore commented lines
        if (!item.startsWith('//')) {
            // TODO we should also remove the other suggestions if used (default()...)
            if (item.includes('@id')) {
                suggestions = suggestions.filter((attribute) => !attribute.label.includes('id'));
            }
        }
    }
    return suggestions;
}
exports.filterSuggestionsForBlock = filterSuggestionsForBlock;
/**
 * Removes all line attribute suggestions that are invalid in this context.
 * E.g. `@map()` when already used should not be in the suggestions.
 */
function filterSuggestionsForLine(suggestions, currentLine, fieldType, fieldBlockType) {
    if (fieldBlockType === 'type') {
        // @default & @relation are invalid on field referencing a composite type
        // we filter them out
        suggestions = suggestions.filter((sugg) => sugg.label !== '@default' && sugg.label !== '@relation');
    }
    // Tom: I think we allow ids on basically everything except relation fields
    // so it doesn't need to be restricted to Int and String.
    // These are terrible, terrible ideas of course, but you can have id DateTime @id or id Float @id.
    // TODO: decide if we want to only suggest things that make most sense or everything that is technically possible.
    const isAtIdAllowed = fieldType === 'Int' || fieldType === 'String' || fieldBlockType === 'enum';
    if (!isAtIdAllowed) {
        // id not allowed
        suggestions = suggestions.filter((suggestion) => suggestion.label !== '@id');
    }
    const isUpdatedAtAllowed = fieldType === 'DateTime';
    if (!isUpdatedAtAllowed) {
        // updatedAt not allowed
        suggestions = suggestions.filter((suggestion) => suggestion.label !== '@updatedAt');
    }
    if (currentLine.includes('@map')) {
        suggestions = suggestions.filter((suggestion) => suggestion.label !== '@map');
    }
    return suggestions;
}
exports.filterSuggestionsForLine = filterSuggestionsForLine;
/**
 * Removes all field suggestion that are invalid in this context. E.g. fields that are used already in a block will not be suggested again.
 * This function removes all field suggestion that are invalid in a certain context. E.g. in a generator block `provider, output, platforms, pinnedPlatForm`
 * are possible fields. But those fields are only valid suggestions if they haven't been used in this block yet. So in case `provider` has already been used, only
 * `output, platforms, pinnedPlatform` will be suggested.
 */
function removeInvalidFieldSuggestions(supportedFields, block, lines, position) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.range.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine || key === position.line) {
            continue;
        }
        if (key === block.range.end.line) {
            break;
        }
        const fieldName = item.replace(/ .*/, '');
        if (supportedFields.includes(fieldName)) {
            supportedFields = supportedFields.filter((field) => field !== fieldName);
        }
    }
    return supportedFields;
}
exports.removeInvalidFieldSuggestions = removeInvalidFieldSuggestions;
function handlePreviewFeatures(previewFeaturesArray, position, currentLineUntrimmed, isInsideQuotation) {
    let previewFeatures = previewFeaturesArray.map((pf) => vscode_languageserver_1.CompletionItem.create(pf));
    if ((0, util_1.isInsideAttribute)(currentLineUntrimmed, position, '[]')) {
        if (isInsideQuotation) {
            const usedValues = (0, util_1.getValuesInsideSquareBrackets)(currentLineUntrimmed);
            previewFeatures = previewFeatures.filter((t) => !usedValues.includes(t.label));
            return {
                items: previewFeatures,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: exports.previewFeaturesArguments.filter((arg) => !arg.label.includes('[')),
                isIncomplete: true,
            };
        }
    }
    else {
        return {
            items: exports.previewFeaturesArguments.filter((arg) => !arg.label.includes('"')),
            isIncomplete: true,
        };
    }
}
exports.handlePreviewFeatures = handlePreviewFeatures;
function getNativeTypes(document, prismaType, onError) {
    let nativeTypes = (0, nativeTypes_1.default)(document.getText(), (errorMessage) => {
        if (onError) {
            onError(errorMessage);
        }
    });
    if (nativeTypes.length === 0) {
        console.log('Did not receive any native type suggestions from prisma-fmt call.');
        return [];
    }
    const suggestions = [];
    nativeTypes = nativeTypes.filter((n) => n.prisma_types.includes(prismaType));
    nativeTypes.forEach((element) => {
        if (element._number_of_args + element._number_of_optional_args !== 0) {
            const documentation = buildDocumentation(element);
            suggestions.push({
                label: `${element.name}()`,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                insertText: `${element.name}($0)`,
                documentation: { kind: vscode_languageserver_1.MarkupKind.Markdown, value: documentation },
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            });
        }
        else {
            suggestions.push({
                label: element.name,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
            });
        }
    });
    return suggestions;
}
exports.getNativeTypes = getNativeTypes;
const buildDocumentation = (element, documentation = '') => {
    if (element._number_of_optional_args !== 0) {
        documentation = `${documentation}Number of optional arguments: ${element._number_of_optional_args}.\n`;
    }
    if (element._number_of_args !== 0) {
        documentation = `${documentation}Number of required arguments: ${element._number_of_args}.\n`;
    }
    return documentation;
};
//# sourceMappingURL=completionUtils.js.map