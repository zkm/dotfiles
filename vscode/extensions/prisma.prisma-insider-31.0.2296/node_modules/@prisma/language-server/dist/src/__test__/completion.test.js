"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const MessageHandler_1 = require("../MessageHandler");
const vscode_languageserver_1 = require("vscode-languageserver");
const assert_1 = __importDefault(require("assert"));
const ts_dedent_1 = __importDefault(require("ts-dedent"));
const helper_1 = require("./helper");
const baseSchema = (provider, previewFeatures) => {
    if (!provider && (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.length) === 0) {
        throw new Error(`provider and/or previewFeatures is required.`);
    }
    let base = '';
    if (provider) {
        base = /* Prisma */ `
  datasource db {
    provider = "${provider}"
    url      = env("DATABASE_URL")
  }`;
    }
    if (previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.length) {
        base += /* Prisma */ `
  generator js {
    provider        = "prisma-client-js"
    previewFeatures = ["${previewFeatures.join('","')}"]
  }`;
    }
    return (0, ts_dedent_1.default)(base);
};
function assertCompletion({ provider, previewFeatures, schema, expected, }) {
    // Remove indentation
    schema = (0, ts_dedent_1.default)(schema);
    if (provider || previewFeatures) {
        schema = `
    ${baseSchema(provider, previewFeatures)}
    ${schema}
    `;
    }
    const position = (0, helper_1.findCursorPosition)(schema);
    const document = vscode_languageserver_textdocument_1.TextDocument.create('completions/none.prisma', 'prisma', 1, schema.replace(helper_1.CURSOR_CHARACTER, ''));
    const completionParams = {
        textDocument: document,
        position,
        context: {
            triggerKind: vscode_languageserver_1.CompletionTriggerKind.Invoked,
        },
    };
    const completionResult = (0, MessageHandler_1.handleCompletionRequest)(completionParams, document);
    assert_1.default.ok(completionResult !== undefined);
    assert_1.default.deepStrictEqual(completionResult.isIncomplete, expected.isIncomplete, `Line ${position.line} - Character ${position.character}
Expected isIncomplete to be '${expected.isIncomplete}' but got '${completionResult.isIncomplete}'`);
    assert_1.default.deepStrictEqual(completionResult.items.map((item) => item.label), expected.items.map((item) => item.label), `Line ${position.line} - Character ${position.character}
mapped items => item.label`);
    assert_1.default.deepStrictEqual(completionResult.items.map((item) => item.kind), expected.items.map((item) => item.kind), `Line ${position.line} - Character ${position.character}
mapped items => item.kind`);
    assert_1.default.deepStrictEqual(completionResult.items.length, expected.items.length, `Line ${position.line} - Character ${position.character}
Expected ${expected.items.length} suggestions and got ${completionResult.items.length}: ${JSON.stringify(completionResult.items, undefined, 2)}`);
    assert_1.default.deepStrictEqual(completionResult.items.length, expected.items.length, `Line ${position.line} - Character ${position.character}
items.length`);
}
suite('Completions', function () {
    // used in more than 1 suite
    const fieldProvider = {
        label: 'provider',
        kind: vscode_languageserver_1.CompletionItemKind.Field,
    };
    const staticValueTrue = {
        label: 'true',
        kind: vscode_languageserver_1.CompletionItemKind.Value,
    };
    const staticValueFalse = {
        label: 'false',
        kind: vscode_languageserver_1.CompletionItemKind.Value,
    };
    const fieldsProperty = {
        label: 'fields',
        kind: vscode_languageserver_1.CompletionItemKind.Property,
    };
    const mapProperty = {
        label: 'map',
        kind: vscode_languageserver_1.CompletionItemKind.Property,
    };
    const sortProperty = {
        label: 'sort',
        kind: vscode_languageserver_1.CompletionItemKind.Property,
    };
    const nameProperty = {
        label: 'name',
        kind: vscode_languageserver_1.CompletionItemKind.Property,
    };
    suite('BASE BLOCKS', () => {
        test('Diagnoses block type suggestions for empty file', () => {
            assertCompletion({
                schema: /* Prisma */ `|`,
                expected: {
                    isIncomplete: false,
                    items: [
                        { label: 'datasource', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'generator', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'model', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'enum', kind: vscode_languageserver_1.CompletionItemKind.Class },
                    ],
                },
            });
        });
        test('Diagnoses block type suggestions with sqlite as provider', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          provider = "sqlite"
        }
        |
        `,
                expected: {
                    isIncomplete: false,
                    items: [
                        { label: 'datasource', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'generator', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'model', kind: vscode_languageserver_1.CompletionItemKind.Class },
                    ],
                },
            });
        });
        test('Diagnoses block type suggestions with mongodb as provider', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          provider = "mongodb"
        }
        |
        `,
                expected: {
                    isIncomplete: false,
                    items: [
                        { label: 'datasource', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'generator', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'model', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'enum', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'type', kind: vscode_languageserver_1.CompletionItemKind.Class },
                    ],
                },
            });
        });
        test('Diagnoses block type suggestions for view preview', () => {
            assertCompletion({
                schema: /* Prisma */ `
        generator client {
          provider        = "prisma-client-js"
          previewFeatures = ["views"]
        }
        |
        `,
                expected: {
                    isIncomplete: false,
                    items: [
                        { label: 'datasource', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'generator', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'model', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'enum', kind: vscode_languageserver_1.CompletionItemKind.Class },
                        { label: 'view', kind: vscode_languageserver_1.CompletionItemKind.Class },
                    ],
                },
            });
        });
    });
    suite('DATABASE BLOCK', () => {
        const fieldUrl = { label: 'url', kind: vscode_languageserver_1.CompletionItemKind.Field };
        const fieldDirectUrl = { label: 'directUrl', kind: vscode_languageserver_1.CompletionItemKind.Field };
        const fieldShadowDatabaseUrl = {
            label: 'shadowDatabaseUrl',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const fieldRelationMode = {
            label: 'relationMode',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const fieldPostgresqlExtensions = {
            label: 'extensions',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const fieldSchemas = {
            label: 'schemas',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const sqlite = { label: 'sqlite', kind: vscode_languageserver_1.CompletionItemKind.Constant };
        const mysql = { label: 'mysql', kind: vscode_languageserver_1.CompletionItemKind.Constant };
        const postgresql = {
            label: 'postgresql',
            kind: vscode_languageserver_1.CompletionItemKind.Constant,
        };
        const sqlserver = {
            label: 'sqlserver',
            kind: vscode_languageserver_1.CompletionItemKind.Constant,
        };
        const mongodb = { label: 'mongodb', kind: vscode_languageserver_1.CompletionItemKind.Constant };
        const cockroachdb = {
            label: 'cockroachdb',
            kind: vscode_languageserver_1.CompletionItemKind.Constant,
        };
        const relationModeForeignKeys = {
            label: 'foreignKeys',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const relationModePrisma = {
            label: 'prisma',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const relationModeForeignKeysWithQuotes = {
            label: '"foreignKeys"',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const relationModePrismaWithQuotes = {
            label: '"prisma"',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const quotationMarks = {
            label: '""',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const env = { label: 'env()', kind: vscode_languageserver_1.CompletionItemKind.Property };
        test('Diagnoses datasource field suggestions in empty block', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldProvider, fieldUrl, fieldShadowDatabaseUrl, fieldDirectUrl, fieldRelationMode],
                },
            });
        });
        test('Diagnoses datasource field suggestions with existing field', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          provider = "sqlite"
          |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldProvider, fieldUrl, fieldShadowDatabaseUrl, fieldDirectUrl, fieldRelationMode],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          url      = env("DATABASE_URL")
          |      
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldProvider, fieldUrl, fieldShadowDatabaseUrl, fieldDirectUrl, fieldRelationMode],
                },
            });
        });
        test('url = env("|")', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
            url = |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [env, quotationMarks],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
            url = env("|")
        }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        {
                            label: 'DATABASE_URL',
                            kind: vscode_languageserver_1.CompletionItemKind.Constant,
                        },
                    ],
                },
            });
        });
        test('shadowDatabaseUrl = env("|")', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
            url = |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [env, quotationMarks],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          shadowDatabaseUrl = env("|")
        }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        {
                            label: 'SHADOW_DATABASE_URL',
                            kind: vscode_languageserver_1.CompletionItemKind.Constant,
                        },
                    ],
                },
            });
        });
        test('directUrl = env("|")', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
            url = |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [env, quotationMarks],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
            directUrl = env("|")
        }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        {
                            label: 'DIRECT_URL',
                            kind: vscode_languageserver_1.CompletionItemKind.Constant,
                        },
                    ],
                },
            });
        });
        test('Diagnoses field extensions availability', () => {
            assertCompletion({
                schema: /* Prisma */ `
          generator client {
            provider        = "prisma-client-js"
            previewFeatures = ["postgresqlExtensions"]
          }

          datasource db {
            provider = "postgresql"
            url = env("DATABASE_URL")
            |
          }
        `,
                expected: {
                    isIncomplete: false,
                    items: [fieldShadowDatabaseUrl, fieldDirectUrl, fieldRelationMode, fieldPostgresqlExtensions],
                },
            });
        });
        test('Diagnoses field schemas', () => {
            assertCompletion({
                schema: /* Prisma */ `
          generator client {
            provider = "prisma-client-js"
            previewFeatures = ["multiSchema"]
          }

          datasource db {
            provider = "cockroachdb"
            url = env("DATABASE_URL")
            |
          }
        `,
                expected: {
                    isIncomplete: false,
                    items: [fieldShadowDatabaseUrl, fieldDirectUrl, fieldRelationMode, fieldSchemas],
                },
            });
        });
        test('provider = "|"', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
         provider = "|"
        }`,
                expected: {
                    isIncomplete: true,
                    items: [mysql, postgresql, sqlite, sqlserver, mongodb, cockroachdb],
                },
            });
        });
        test('provider = |', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          provider = |
        }`,
                expected: {
                    isIncomplete: true,
                    items: [quotationMarks],
                },
            });
        });
        test('relationMode = "|"', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          provider = "sqlite"
          relationMode = "|"
        }`,
                expected: {
                    isIncomplete: false,
                    items: [relationModeForeignKeys, relationModePrisma],
                },
            });
        });
        test('relationMode = |', () => {
            assertCompletion({
                schema: /* Prisma */ `
        datasource db {
          relationMode = |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [relationModeForeignKeysWithQuotes, relationModePrismaWithQuotes],
                },
            });
        });
    });
    suite('GENERATOR BLOCK', () => {
        // fieldProvider defined above already
        const fieldOutput = { label: 'output', kind: vscode_languageserver_1.CompletionItemKind.Field };
        const fieldBinaryTargets = {
            label: 'binaryTargets',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const fieldPreviewFeatures = {
            label: 'previewFeatures',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        const fieldEngineType = {
            label: 'engineType',
            kind: vscode_languageserver_1.CompletionItemKind.Field,
        };
        test('Diagnoses generator field suggestions in empty block', () => {
            assertCompletion({
                schema: /* Prisma */ `
        generator gen {
          |
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldProvider, fieldPreviewFeatures, fieldOutput, fieldEngineType, fieldBinaryTargets],
                },
            });
        });
        test('Diagnoses generator field suggestions with existing fields', () => {
            assertCompletion({
                schema: /* Prisma */ `
          generator gen {
            provider = 'sqlite'
            |
          }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldPreviewFeatures, fieldOutput, fieldEngineType, fieldBinaryTargets],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
          generator gen {
            output  = "node_modules/@prisma/client"
            |
          }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldProvider, fieldPreviewFeatures, fieldEngineType, fieldBinaryTargets],
                },
            });
        });
        test('engineType = |', () => {
            assertCompletion({
                schema: /* Prisma */ `
          generator gen {
            engineType = |
          }`,
                expected: {
                    isIncomplete: true,
                    items: [
                        {
                            label: '""',
                            kind: vscode_languageserver_1.CompletionItemKind.Property,
                        },
                    ],
                },
            });
        });
        test('engineType = "|"', () => {
            assertCompletion({
                schema: /* Prisma */ `
          generator gen {
            engineType = "|"
          }`,
                expected: {
                    isIncomplete: true,
                    items: [
                        {
                            label: 'library',
                            kind: vscode_languageserver_1.CompletionItemKind.Constant,
                        },
                        {
                            label: 'binary',
                            kind: vscode_languageserver_1.CompletionItemKind.Constant,
                        },
                        {
                            label: 'dataproxy',
                            kind: vscode_languageserver_1.CompletionItemKind.Constant,
                        },
                    ],
                },
            });
        });
    });
    suite('BLOCK ATTRIBUTES', () => {
        const blockAttributeId = {
            label: '@@id',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const blockAttributeMap = {
            label: '@@map',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const blockAttributeUnique = {
            label: '@@unique',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const blockAttributeIndex = {
            label: '@@index',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const blockAttributeFulltextIndex = {
            label: '@@fulltext',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const blockAttributeIgnore = {
            label: '@@ignore',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const blockAttributeSchema = {
            label: '@@schema',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const typeProperty = {
            label: 'type',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const namespaceOne = {
            label: 'one',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const namespaceTwo = {
            label: 'two',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        test('@@id([|])', () => {
            assertCompletion({
                schema: /* Prisma */ `
              model ThirdUser {
                  firstName String
                  lastName String
                  isAdmin Boolean @default(false)
                  @@id([|])
              }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        { label: 'firstName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        { label: 'lastName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        { label: 'isAdmin', kind: vscode_languageserver_1.CompletionItemKind.Field },
                    ],
                },
            });
        });
        suite('First in a line', () => {
            test('Empty model', () => {
                assertCompletion({
                    schema: /* Prisma */ `
          model user {
            |
          }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            blockAttributeMap,
                            blockAttributeId,
                            blockAttributeUnique,
                            blockAttributeIndex,
                            blockAttributeIgnore,
                        ],
                    },
                });
            });
            test('Model', () => {
                assertCompletion({
                    schema: /* Prisma */ `
          model User {
            firstName String
            lastName String
            email String @unique
            isAdmin Boolean @default(false)
            |
          }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            blockAttributeMap,
                            blockAttributeId,
                            blockAttributeUnique,
                            blockAttributeIndex,
                            blockAttributeIgnore,
                        ],
                    },
                });
                assertCompletion({
                    schema: /* Prisma */ `
          model Post {
            id Int @id @default()
            email String? @unique
            name String 
            |
          }`,
                    expected: {
                        isIncomplete: false,
                        items: [blockAttributeMap, blockAttributeUnique, blockAttributeIndex, blockAttributeIgnore],
                    },
                });
            });
            test('View', () => {
                assertCompletion({
                    schema: /* Prisma */ `
          view User {
            firstName String
            lastName String
            email String @unique
            isAdmin Boolean @default(false)
            |
          }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            blockAttributeMap,
                            blockAttributeId,
                            blockAttributeUnique,
                            blockAttributeIndex,
                            blockAttributeIgnore,
                        ],
                    },
                });
            });
            suite('fullTextIndex', () => {
                test('MySQL', () => {
                    assertCompletion({
                        provider: 'mysql',
                        previewFeatures: ['fullTextIndex'],
                        schema: /* Prisma */ `
          model Fulltext {
            id      Int    @id
            title   String @db.VarChar(255)
            content String @db.Text
            |
            @@fulltext()
            @@fulltext([title, content], )
          }          
          `,
                        expected: {
                            isIncomplete: false,
                            items: [
                                blockAttributeMap,
                                // blockAttributeId,
                                blockAttributeUnique,
                                blockAttributeIndex,
                                blockAttributeFulltextIndex,
                                blockAttributeIgnore,
                            ],
                        },
                    });
                });
                test('MongoDB', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        previewFeatures: ['fullTextIndex'],
                        schema: /* Prisma */ `
          model Fulltext {
            id      String @id @map("_id") @db.ObjectId
            title   String
            content String
            |
            @@fulltext()
            @@fulltext([title, content], )
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                blockAttributeMap,
                                // blockAttributeId,
                                blockAttributeUnique,
                                blockAttributeIndex,
                                blockAttributeFulltextIndex,
                                blockAttributeIgnore,
                            ],
                        },
                    });
                });
                test('PostgreSQL', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        previewFeatures: ['fullTextIndex'],
                        schema: /* Prisma */ `
            model A {
              id    Int @id
              title   String
              content String
              |
            }
          `,
                        expected: {
                            isIncomplete: false,
                            items: [
                                blockAttributeMap,
                                // blockAttributeId,
                                blockAttributeUnique,
                                blockAttributeIndex,
                                blockAttributeIgnore,
                            ],
                        },
                    });
                });
            });
        });
        suite('@@unique()', function () {
            suite('No provider', function () {
                test('@@unique([|])', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
          model SecondUser {
            firstName String
            lastName String
            isAdmin Boolean @default(false)
            @@unique([|])
        }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'firstName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'lastName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'isAdmin', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@unique(fields: [|])', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
          model SecondUser {
            firstName String
            lastName String
            isAdmin Boolean @default(false)
            @@unique(fields: [|])
        }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'firstName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'lastName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'isAdmin', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
            });
            suite('MongoDB', function () {
                test('@@unique([|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@unique([|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'address', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@unique(fields: [|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@unique(fields: [|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'address', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
            });
        });
        suite('@@index()', function () {
            suite('No provider', function () {
                test('@@index([|])', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
          model ThirdUser {
              firstName String
              lastName String
              isAdmin Boolean @default(false)
              @@index([|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'firstName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'lastName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'isAdmin', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index(fields: [|])', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
          model ThirdUser {
              firstName String
              lastName String
              isAdmin Boolean @default(false)
              @@index(field: [|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'firstName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'lastName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'isAdmin', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
            });
            suite('MongoDB', function () {
                test('@@index([|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'address', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([a|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            account Int
            @@index([a|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                // These are returned, but `onCompletionResolve` will only complete with the current match
                                // which means the completion will actually be
                                // address and account
                                // TODO create a test that shows that
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'address', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'account', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([address|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            account Int
            @@index([address|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                // These are returned though the completion will actually be
                                // No suggestions
                                // TODO create a test that shows that
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'account', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([address,|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([address,|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([address, |])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([address, |])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([address.|]) first position, with only one type', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([address.|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'street', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'number', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([address.|]) with composite type suggestion 1', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([address.|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'street', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'number', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'alpha', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([address.a|]) with composite type suggestion 1', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([address.a|])
          }`,
                        expected: {
                            isIncomplete: false,
                            // TODO, see if we can have better suggestions here, should suggest `alpha`
                            items: [],
                        },
                    });
                });
                test('@@index([email,address.|]) with composite type suggestion, depth 1', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([email,address.|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'street', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'number', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'alpha', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([email, address.|]) with composite type suggestion, depth 1', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([email, address.|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'street', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'number', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'alpha', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([email, address.alpha.|]) with composite type suggestion, depth 2', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([email, address.alpha.|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'bravo', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'helloA', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([email, address.alpha.bravo.|]) with composite type suggestion, depth 3', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([email, address.alpha.bravo.|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'something', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'helloBravo', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
                test('@@index([email, address.alpha.bravo.hello|]) with composite type suggestion, depth 3', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
            alpha  Alpha
          }
          type Alpha {
            bravo  Bravo
            helloA Int
          }
          type Bravo {
            something  String
            helloBravo Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index([email, address.alpha.bravo.hello||])
          }`,
                        expected: {
                            isIncomplete: false,
                            // TODO, see if we can have better suggestions here, should suggest `helloBravo`
                            items: [],
                        },
                    });
                });
                test('@@index(fields: [|])', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
          type Address {
            street String
            number Int
          }
          model User {
            id      Int     @id @map("_id")
            email   String
            address Address
            @@index(fields: [|])
          }`,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'email', kind: vscode_languageserver_1.CompletionItemKind.Field },
                                { label: 'address', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            ],
                        },
                    });
                });
            });
            suite('extendedIndexes - PostgreSQL', function () {
                test('@@index(|)', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
          model A {
            id    Int @id
            title   String
            content String
            
            @@index(|)
          }
        `,
                        expected: {
                            isIncomplete: false,
                            items: [fieldsProperty, mapProperty, typeProperty],
                        },
                    });
                });
                test('@@index([title], |) - postgresql', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
        model A {
          id    Int @id
          title   String
          content String
          
          @@index([title], |)
        }
      `,
                        expected: {
                            isIncomplete: false,
                            items: [fieldsProperty, mapProperty, typeProperty],
                        },
                    });
                });
                test('@@index([title], type: |) - postgresql', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
        model A {
          id    Int @id
          title   String
          content String
          
          @@index([title], type: |)
        }
      `,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'BTree', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                                { label: 'Hash', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                                { label: 'Gist', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                                { label: 'Gin', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                                { label: 'SpGist', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                                { label: 'Brin', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            ],
                        },
                    });
                });
                test('@@index([title], type: Hash, |) - postgresql', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
        model A {
          id    Int @id
          title   String
          content String
          
          @@index([title], type: Hash, |)
        }
      `,
                        expected: {
                            isIncomplete: false,
                            items: [fieldsProperty, mapProperty],
                        },
                    });
                });
                test('@@index([title(|)]) - postgresql', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
        model A {
          id    Int @id
          title   String
          content String
          
          @@index([title(|)])
        }
      `,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'ops', kind: vscode_languageserver_1.CompletionItemKind.Property },
                                { label: 'sort', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            ],
                        },
                    });
                });
                test('@@index([title(ops: |)]) - postgresql', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
        model A {
          id    Int @id
          title   String @db.Inet
          content String
          
          @@index([title(ops: |)])
        }
      `,
                        expected: {
                            isIncomplete: false,
                            items: [{ label: 'raw', kind: vscode_languageserver_1.CompletionItemKind.Function }],
                        },
                    });
                });
                test('@@index([title(ops: |)], type: Gist) - postgresql', () => {
                    assertCompletion({
                        provider: 'postgresql',
                        schema: /* Prisma */ `
        model A {
          id    Int @id
          title   String @db.Inet
          content String
          
          @@index([title(ops: |)], type: Gist)
        }
      `,
                        expected: {
                            isIncomplete: false,
                            items: [
                                { label: 'InetOps', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                                { label: 'raw', kind: vscode_languageserver_1.CompletionItemKind.Function },
                            ],
                        },
                    });
                });
            });
        });
        suite('@@fulltext()', function () {
            test('@@fulltext(|) - mysql', () => {
                assertCompletion({
                    provider: 'mysql',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `
          model Fulltext {
            id      Int    @id
            title   String @db.VarChar(255)
            content String @db.Text
            
            @@fulltext(|)
            @@fulltext([title, content], )
          }          
          `,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
            test('@@fulltext([title, content], |) - mysql', () => {
                assertCompletion({
                    provider: 'mysql',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `
          model Fulltext {
            id      Int    @id
            title   String @db.VarChar(255)
            content String @db.Text
            
            @@fulltext()
            @@fulltext([title, content], |)
          }          
          `,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
            test('@@fulltext(|) - mongodb', () => {
                assertCompletion({
                    provider: 'mongodb',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `
          model Fulltext {
            id      String @id @map("_id") @db.ObjectId
            title   String
            content String
            
            @@fulltext(|)
            @@fulltext([title, content], )
          }

          // https://www.prisma.io/docs/concepts/components/prisma-schema/indexes#examples
          // On MongoDB, the fullTextIndex and extendedIndexes preview features can be combined
          // to add fields in ascending or descending order to your full-text index:
          model Post {
            id      String @id @map("_id") @db.ObjectId
            title   String
            content String

            @@fulltext([title(sort: Desc), content])
          }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
            test('@@fulltext([title, content], |) - mongodb', () => {
                assertCompletion({
                    provider: 'mongodb',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `

          model Fulltext {
            id      String @id @map("_id") @db.ObjectId
            title   String
            content String
            
            @@fulltext()
            @@fulltext([title, content], |)
          }

          // https://www.prisma.io/docs/concepts/components/prisma-schema/indexes#examples
          // On MongoDB, the fullTextIndex and extendedIndexes preview features can be combined
          // to add fields in ascending or descending order to your full-text index:
          model Post {
            id      String @id @map("_id") @db.ObjectId
            title   String
            content String

            @@fulltext([title(sort: Desc), content])
          }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
        });
        suite('@@schema()', () => {
            test('@@schema - postgres', () => {
                assertCompletion({
                    provider: 'postgresql',
                    previewFeatures: ['multiSchema'],
                    schema: /* prisma */ `
            model Schema {
              id Int @id
              |
            }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            blockAttributeMap,
                            blockAttributeUnique,
                            blockAttributeIndex,
                            blockAttributeIgnore,
                            blockAttributeSchema,
                        ],
                    },
                });
            });
            test('@@schema(|) - postgres', () => {
                assertCompletion({
                    schema: /* prisma */ `
            generator client {
              provider = "prisma-client-js"
              previewFeatures = ["multiSchema"]
            }
            datasource db {
              provider = "postgresql"
              url = env("DATABASE_URL")
              schemas = ["one", "two"]
            }

            model Schema {
              id Int @id
              @@schema(|)
            }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [namespaceOne, namespaceTwo],
                    },
                });
            });
        });
    });
    suite('TYPES', () => {
        suite('Views', () => {
            test('Field Types', () => {
                assertCompletion({
                    schema: /* Prisma */ `
          view A {
            name |
          }
          `,
                    expected: {
                        isIncomplete: true,
                        items: [
                            { label: 'String', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Boolean', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Int', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Float', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'DateTime', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Json', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Bytes', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Decimal', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'BigInt', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            {
                                label: 'Unsupported',
                                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                            },
                            { label: 'A', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        ],
                    },
                });
            });
            test('Field Attributes', () => {
                assertCompletion({
                    provider: 'postgresql',
                    schema: /* Prisma */ `
          view A {
            name String |
          }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: '@db', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            { label: '@id', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            { label: '@unique', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            { label: '@map', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            { label: '@default', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            { label: '@relation', kind: vscode_languageserver_1.CompletionItemKind.Property },
                            { label: '@ignore', kind: vscode_languageserver_1.CompletionItemKind.Property },
                        ],
                    },
                });
            });
        });
        test('Diagnoses type suggestions in model - No datasource', () => {
            assertCompletion({
                schema: /* Prisma */ `
        model User {
            firstName String
            lastName String
            email String @unique
            isAdmin Boolean @default(false)
        }
        model Post {
            id Int @id @default()
            email String? @unique
            name String 
        }
        model Person {
            id String 
            name Post 
        }
        model Test {
          email    String  @unique
          isAdmin  Boolean @default()
        }
        model Cat {
            id String @id @default()
            name String
            createdAt  DateTime    @default()
        }
        model SecondUser {
            firstName String
            lastName String
            isAdmin Boolean @default(false)
            @@unique([])
        }
        model ThirdUser {
            firstName String
            lastName String
            isAdmin Boolean @default(false)
            @@id([])
            @@index([])
        }
        model TypeCheck {
          // Here!
            hi |
        }
        enum Hello {
            Hey
            Hallo
        }
        model DateTest {
            id Int @id @default(autoincrement())
            update DateTime  
            type UserType @default()
        }
        enum UserType {
            ADMIN
            NORMAL
        }
        model ForthUser {
            firstName String
            lastName String

            @@index([firstName, ])
            @@fulltext()
            @@fulltext([])
        }
        view FifthUser {
            firstName String @unique
        }
        `,
                expected: {
                    isIncomplete: true,
                    items: [
                        { label: 'String', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Boolean', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Int', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Float', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'DateTime', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Json', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Bytes', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Decimal', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'BigInt', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        {
                            label: 'Unsupported',
                            kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                        },
                        { label: 'User', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'Post', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'Person', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'Test', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'Cat', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'SecondUser', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'ThirdUser', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'TypeCheck', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'Hello', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'DateTest', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'UserType', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'ForthUser', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'FifthUser', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                    ],
                },
            });
        });
        // TODO should suggest `MyType`?
        test('Diagnoses type suggestions in model - MongoDB', () => {
            assertCompletion({
                provider: 'mongodb',
                schema: /* Prisma */ `
        model Post {
          something |
        }
        enum PostType {
          ADMIN
          NORMAL
        }
        model Something {
          id Int @id @default() @map("_id") @db.ObjectId
        }
        type MyType {
          text String
        }
      `,
                expected: {
                    isIncomplete: true,
                    items: [
                        { label: 'String', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Boolean', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Int', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Float', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'DateTime', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Json', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'Bytes', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        { label: 'BigInt', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        {
                            label: 'Unsupported',
                            kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                        },
                        { label: 'Post', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'PostType', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        { label: 'Something', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                    ],
                },
            });
        });
        test('Diagnoses type suggestions in model - SQLite, PostgreSQL, MySQL, SQL Server, CockroachDB', () => {
            for (const provider of ['sqlite', 'postgresql', 'mysql', 'sqlserver', 'cockroachdb']) {
                console.info(`provider = ${provider}`);
                assertCompletion({
                    provider: provider,
                    schema: /* Prisma */ `
            model Post {
              something |
            }
            enum PostType {
              ADMIN
              NORMAL
            }
            model Something {
              id Int @id
            }
          `,
                    expected: {
                        isIncomplete: true,
                        items: [
                            { label: 'String', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Boolean', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Int', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Float', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'DateTime', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Json', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Bytes', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Decimal', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'BigInt', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            {
                                label: 'Unsupported',
                                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                            },
                            { label: 'Post', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                            { label: 'PostType', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                            { label: 'Something', kind: vscode_languageserver_1.CompletionItemKind.Reference },
                        ],
                    },
                });
            }
        });
    });
    suite('NATIVE TYPES', () => {
        suite('CockroachDB', () => {
            test('String', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something String @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Bit()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Char()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Inet', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'CatalogSingleChar', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'String()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Uuid', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'VarBit()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        ],
                    },
                });
            });
            test('Boolean', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something Boolean @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [{ label: 'Bool', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter }],
                    },
                });
            });
            test('Int', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something Int @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Int2', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Int4', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Oid', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        ],
                    },
                });
            });
            test('Float', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something Float @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Float4', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Float8', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        ],
                    },
                });
            });
            test('DateTime', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something DateTime @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Date', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Time()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Timestamp()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Timestamptz()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Timetz()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        ],
                    },
                });
            });
            test('Json', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something Json @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [{ label: 'JsonB', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter }],
                    },
                });
            });
            test('Diagnoses Native Types suggestions - CockroachDB - Bytes', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something Bytes @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [{ label: 'Bytes', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter }],
                    },
                });
            });
            test('Decimal', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something Decimal @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [{ label: 'Decimal()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter }],
                    },
                });
            });
            test('BigInt', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
        model Post {
          something BigInt @db.|
        }
      `,
                    expected: {
                        isIncomplete: false,
                        items: [{ label: 'Int8', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter }],
                    },
                });
            });
            test('View - String', () => {
                assertCompletion({
                    provider: 'cockroachdb',
                    schema: /* Prisma */ `
            view Post {
              something String @db.|
            }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Bit()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Char()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Inet', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'CatalogSingleChar', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'String()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'Uuid', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                            { label: 'VarBit()', kind: vscode_languageserver_1.CompletionItemKind.TypeParameter },
                        ],
                    },
                });
            });
        });
    });
    suite('FIELD ATTRIBUTES', () => {
        const fieldAttributeId = {
            label: '@id',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeUnique = {
            label: '@unique',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeMap = {
            label: '@map',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeDefault = {
            label: '@default',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeRelation = {
            label: '@relation',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeUpdatedAt = {
            label: '@updatedAt',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeIgnore = {
            label: '@ignore',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const fieldAttributeDatasourceName = {
            label: '@db',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const functionCuid = {
            label: 'cuid()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const functionUuid = {
            label: 'uuid()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const functionAuto = {
            label: 'auto()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const functionSequence = {
            label: 'sequence()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const functionAutoincrement = {
            label: 'autoincrement()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const functionNow = {
            label: 'now()',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const functionDbGenerated = {
            label: 'dbgenerated("")',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
        };
        const staticValueEmptyList = {
            label: '[]',
            kind: vscode_languageserver_1.CompletionItemKind.Value,
        };
        const enumValueOne = {
            label: 'ADMIN',
            kind: vscode_languageserver_1.CompletionItemKind.Value,
        };
        const enumValueTwo = {
            label: 'NORMAL',
            kind: vscode_languageserver_1.CompletionItemKind.Value,
        };
        const referencesProperty = {
            label: 'references',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const onDeleteProperty = {
            label: 'onDelete',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const onUpdateProperty = {
            label: 'onUpdate',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const nameQuotesProperty = {
            label: '""',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const lengthProperty = {
            label: 'length',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        // sequence()
        const minValueProperty = {
            label: 'minValue',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const maxValueProperty = {
            label: 'maxValue',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const cacheProperty = {
            label: 'cache',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const incrementProperty = {
            label: 'increment',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const startProperty = {
            label: 'start',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const virtualProperty = {
            label: 'virtual',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        const asc = {
            label: 'Asc',
            kind: vscode_languageserver_1.CompletionItemKind.Enum,
        };
        const desc = {
            label: 'Desc',
            kind: vscode_languageserver_1.CompletionItemKind.Enum,
        };
        test('Diagnoses field and block attribute suggestions', () => {
            assertCompletion({
                schema: /* Prisma */ `
          model Post {
            id Int @id @default()
            email String? @unique
            name String 
          }

          model Person {
              id String |
              name Post 
          }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        fieldAttributeId,
                        fieldAttributeUnique,
                        fieldAttributeMap,
                        fieldAttributeDefault,
                        fieldAttributeRelation,
                        fieldAttributeIgnore,
                    ],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
          model Post {
            id Int @id @default()
            email String? @unique
            name String 
          }

          model Person {
              id String 
              name Post |
          }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        fieldAttributeUnique,
                        fieldAttributeMap,
                        fieldAttributeDefault,
                        fieldAttributeRelation,
                        fieldAttributeIgnore,
                    ],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
          model DateTest {
            id Int @id @default(autoincrement())
            update DateTime |
            type UserType @default()
          }

          enum UserType {
            ADMIN
            NORMAL
          }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        fieldAttributeUnique,
                        fieldAttributeMap,
                        fieldAttributeDefault,
                        fieldAttributeRelation,
                        fieldAttributeUpdatedAt,
                        fieldAttributeIgnore,
                    ],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
            model Post {
                id Int @id @default()
                email String? @unique
                name String |
            }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        fieldAttributeUnique,
                        fieldAttributeMap,
                        fieldAttributeDefault,
                        fieldAttributeRelation,
                        fieldAttributeIgnore,
                    ],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
          model ForthUser {
            firstName String
            lastName String

            @@index([firstName, |])
          }`,
                expected: {
                    isIncomplete: false,
                    items: [{ label: 'lastName', kind: vscode_languageserver_1.CompletionItemKind.Field }],
                },
            });
            assertCompletion({
                provider: 'postgresql',
                schema: /* Prisma */ `
          model Post {
            id Int @id @default() @map("foobar")
            email String? @unique
            name String |
          }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        fieldAttributeDatasourceName,
                        fieldAttributeUnique,
                        fieldAttributeMap,
                        fieldAttributeDefault,
                        fieldAttributeRelation,
                        fieldAttributeIgnore,
                    ],
                },
            });
            assertCompletion({
                schema: /* Prisma */ `
          model Post {
            id Int @id @default()
            email String? @unique
            name String @map("_name")|
          }
        `,
                expected: {
                    isIncomplete: false,
                    items: [fieldAttributeUnique, fieldAttributeDefault, fieldAttributeRelation, fieldAttributeIgnore],
                },
            });
        });
        const enumUserTypeExpectedItems = [
            fieldAttributeId,
            fieldAttributeUnique,
            fieldAttributeMap,
            fieldAttributeDefault,
            fieldAttributeRelation,
            fieldAttributeIgnore,
        ];
        test('enum UserType |', () => {
            assertCompletion({
                schema: /* Prisma */ `
        model DateTest {
          enum UserType |
        }
        enum UserType {
          ADMIN
          NORMAL
        }`,
                expected: {
                    isIncomplete: false,
                    items: enumUserTypeExpectedItems,
                },
            });
        });
        test('enum UserType | with 1 commented field', () => {
            assertCompletion({
                schema: /* Prisma */ `
        model DateTest {
          // id Int @id @default()
          enum UserType |
        }
        enum UserType {
          ADMIN
          NORMAL
        }`,
                expected: {
                    isIncomplete: false,
                    items: enumUserTypeExpectedItems,
                },
            });
        });
        test('field CompositeType |', () => {
            assertCompletion({
                provider: 'mongodb',
                schema: /* Prisma */ `
        model A {
          field CompositeType |
        }
        type CompositeType {
          someting String
        }`,
                expected: {
                    isIncomplete: false,
                    items: [
                        fieldAttributeDatasourceName,
                        fieldAttributeUnique,
                        fieldAttributeMap,
                        // fieldAttributeDefault, is invalid
                        // fieldAttributeRelation, is invalid
                        fieldAttributeIgnore,
                    ],
                },
            });
        });
        suite('@default()', function () {
            test('Scalar lists', () => {
                const scalarTypes = ['String', 'color', 'Int', 'Float', 'Boolean', 'DateTime'];
                for (const scalarType of scalarTypes) {
                    assertCompletion({
                        schema: /* Prisma */ `
              model Test {
                id    Int             @id
                lists ${scalarType}[] @default(|)
              }
              
              enum color {
                RED
                GREEN
                BLUE
              }
              `,
                        expected: {
                            isIncomplete: false,
                            items: [staticValueEmptyList, functionDbGenerated],
                        },
                    });
                }
            });
            suite('No provider', function () {
                test('Int @id @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                    model Post {
                        id Int @id @default(|)
                        email String? @unique
                        name String 
                    }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionAutoincrement],
                        },
                    });
                });
                test('BigInt @id @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                    model Post {
                        id BigInt @id @default(|)
                        email String? @unique
                        name String 
                    }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionAutoincrement],
                        },
                    });
                });
                test('String @id @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                  model Cat {
                    id String @id @default(|)
                    name String
                    createdAt  DateTime @default()
                }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionUuid, functionCuid],
                        },
                    });
                });
                test('DateTime @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                  model Cat {
                    id String @id @default()
                    name String
                    createdAt  DateTime @default(|)
                }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionNow],
                        },
                    });
                });
                test('Boolean @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                  model Test {
                    email    String  @unique
                    isAdmin  Boolean @default(|)
                  }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, staticValueTrue, staticValueFalse],
                        },
                    });
                });
                test('Enum @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                  model DateTest {
                    id Int @id @default(autoincrement())
                    update DateTime  
                    enum UserType @default(|)
                  }
                  enum UserType {
                    ADMIN
                    NORMAL
                  }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, enumValueOne, enumValueTwo],
                        },
                    });
                });
                test('Enum @default(|) (enum with comments)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
              model Test {
                id Int @id
                enum CommentEnum @default(|)
              }
              enum CommentEnum {
                ADMIN
                NORMAL
              }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, enumValueOne, enumValueTwo],
                        },
                    });
                });
            });
            suite('MongoDB', function () {
                test('String @id @default(|)', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
            model Post {
              id       String   @id @default(|) @map("_id") @db.ObjectId
            }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionAuto, functionUuid, functionCuid],
                        },
                    });
                });
                test('Int @id @default(|)', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
            model Something {
              id Int @id @default(|) @map("_id") @db.ObjectId
            }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionAuto, functionAutoincrement],
                        },
                    });
                });
                test('BigInt @id @default(|)', () => {
                    assertCompletion({
                        schema: /* Prisma */ `
                    model Post {
                        id BigInt @id @default(|)
                        email String? @unique
                        name String 
                    }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionAutoincrement],
                        },
                    });
                });
                test('String @default(|)', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
            model Post {
              string   String   @default(|)
            }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionAuto, functionUuid, functionCuid],
                        },
                    });
                });
                test('Boolean @default(|)', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
            model Post {
              boolean  Boolean  @default(|)
            }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionAuto, staticValueTrue, staticValueFalse],
                        },
                    });
                });
                test('DateTime @default(|)', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
            model Post {
              datetime DateTime @default(|)
            }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionAuto, functionNow],
                        },
                    });
                });
                test('Enum @default(|)', () => {
                    assertCompletion({
                        provider: 'mongodb',
                        schema: /* Prisma */ `
            model Post {
              enum     PostType @default(|)
            }
            enum PostType {
              ADMIN
              NORMAL
            }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionAuto, enumValueOne, enumValueTwo],
                        },
                    });
                });
            });
            suite('CockroachDB', function () {
                test('Int @id @default(|)', () => {
                    assertCompletion({
                        provider: 'cockroachdb',
                        schema: /* Prisma */ `
                  model Post {
                      id Int @id @default(|)
                      email String? @unique
                      name String 
                  }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionSequence],
                        },
                    });
                });
                test('BigInt @id @default(|)', () => {
                    assertCompletion({
                        provider: 'cockroachdb',
                        schema: /* Prisma */ `
                  model Post {
                      id BigInt @id @default(|)
                      email String? @unique
                      name String 
                  }`,
                        expected: {
                            isIncomplete: false,
                            items: [functionDbGenerated, functionSequence, functionAutoincrement],
                        },
                    });
                });
                suite('@default(sequence())', function () {
                    test('@default(sequence(|))', () => {
                        assertCompletion({
                            provider: 'cockroachdb',
                            schema: /* Prisma */ `
              model Post {
                  id Int @id @default(sequence(|))
              }`,
                            expected: {
                                isIncomplete: false,
                                items: [
                                    virtualProperty,
                                    minValueProperty,
                                    maxValueProperty,
                                    cacheProperty,
                                    incrementProperty,
                                    startProperty,
                                ],
                            },
                        });
                    });
                    test('@default(sequence(virtual|))', () => {
                        assertCompletion({
                            provider: 'cockroachdb',
                            schema: /* Prisma */ `
              model Post {
                  id Int @id @default(sequence(virtual|))
              }`,
                            expected: {
                                isIncomplete: false,
                                items: [],
                            },
                        });
                    });
                    test('@default(sequence(min|))', () => {
                        assertCompletion({
                            provider: 'cockroachdb',
                            schema: /* Prisma */ `
              model Post {
                  id Int @id @default(sequence(min|))
              }`,
                            expected: {
                                isIncomplete: false,
                                // TODO create a test that shows that the completion is actually `minValue`
                                // because of `onCompletionResolve`
                                items: [
                                    virtualProperty,
                                    minValueProperty,
                                    maxValueProperty,
                                    cacheProperty,
                                    incrementProperty,
                                    startProperty,
                                ],
                            },
                        });
                    });
                    test('@default(sequence(minValue: 10,|))', () => {
                        assertCompletion({
                            provider: 'cockroachdb',
                            schema: /* Prisma */ `
              model Post {
                  id Int @id @default(sequence(minValue: 10,|))
              }`,
                            expected: {
                                isIncomplete: false,
                                items: [maxValueProperty, cacheProperty, incrementProperty, startProperty],
                            },
                        });
                    });
                    test('@default(sequence(minValue: 10, |))', () => {
                        assertCompletion({
                            provider: 'cockroachdb',
                            schema: /* Prisma */ `
              model Post {
                  id Int @id @default(sequence(minValue: 10, |))
              }`,
                            expected: {
                                isIncomplete: false,
                                items: [maxValueProperty, cacheProperty, incrementProperty, startProperty],
                            },
                        });
                    });
                    test('@default(sequence(minValue: 10, maxValue: 39, |))', () => {
                        assertCompletion({
                            provider: 'cockroachdb',
                            schema: /* Prisma */ `
              model Post {
                  id Int @id @default(sequence(minValue: 10, maxValue: 39, |))
              }`,
                            expected: {
                                isIncomplete: false,
                                items: [cacheProperty, incrementProperty, startProperty],
                            },
                        });
                    });
                });
            });
        });
        suite('@relation()', function () {
            test('@relation(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            referencesProperty,
                            fieldsProperty,
                            onDeleteProperty,
                            onUpdateProperty,
                            nameQuotesProperty,
                            nameProperty,
                            mapProperty,
                        ],
                    },
                });
            });
            test('@relation(references: [|])', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model Order {
              id Int @id @default(autoincrement())
              items OrderItem[]
              total Int
            }
            model OrderItemTwo {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(references: [|])
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'items', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'total', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        ],
                    },
                });
            });
            test('MongoDB: embedded m2m @relation(references: [|])', () => {
                assertCompletion({
                    provider: 'mongodb',
                    schema: /* Prisma */ `
            model Bar {
              id      Int   @id @map("_id")
              foo_ids Int[]
              foo     Foo[] @relation(fields: [foo_ids], references: [|])
            }
            model Foo {
              id      Int   @id @map("_id")
              bar_ids Int[]
              bar     Bar[] @relation(fields: [bar_ids], references: [id])
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'bar_ids', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'bar', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        ],
                    },
                });
            });
            test('@relation(references: [id], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(references: [id], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, onDeleteProperty, onUpdateProperty, nameQuotesProperty, nameProperty, mapProperty],
                    },
                });
            });
            test('order Order @relation(fields: [orderId], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(fields: [orderId], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            referencesProperty,
                            onDeleteProperty,
                            onUpdateProperty,
                            nameQuotesProperty,
                            nameProperty,
                            mapProperty,
                        ],
                    },
                });
            });
            // TODO fields shortcut fails
            // test('@relation([|])', () => {
            //   assertCompletion({
            //     schema: /* Prisma */ `
            //       model OrderItem {
            //         id Int @id @default(autoincrement())
            //         productName String
            //         productPrice Int
            //         quantity Int
            //         orderId Int
            //         order Order @relation([|])
            //       }`,
            //     expected: {
            //       isIncomplete: false,
            //       items: [
            //         { label: 'id', kind: CompletionItemKind.Field },
            //         { label: 'productName', kind: CompletionItemKind.Field },
            //         { label: 'productPrice', kind: CompletionItemKind.Field },
            //         { label: 'quantity', kind: CompletionItemKind.Field },
            //         { label: 'orderId', kind: CompletionItemKind.Field },
            //       ],
            //     },
            //   })
            // })
            test('@relation(fields: [|])', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(fields: [|])
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'id', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'productName', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'productPrice', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'quantity', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'orderId', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        ],
                    },
                });
            });
            test('@relation(fields: [orderId], references: [id], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id           Int    @id @default(autoincrement())
              productName  String
              productPrice Int
              quantity     Int
              orderId      Int
              order Order @relation(fields: [orderId], references: [id], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [onDeleteProperty, onUpdateProperty, nameQuotesProperty, nameProperty, mapProperty],
                    },
                });
            });
            test('@relation(onDelete: |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(onDelete: |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Cascade', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'Restrict', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'NoAction', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetNull', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetDefault', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                        ],
                    },
                });
            });
            test('@relation(onUpdate: |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(onUpdate: |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Cascade', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'Restrict', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'NoAction', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetNull', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetDefault', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                        ],
                    },
                });
            });
            test('@relation(fields: [orderId], references: [id], onDelete: |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(fields: [orderId], references: [id], onDelete: |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Cascade', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'Restrict', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'NoAction', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetNull', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetDefault', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                        ],
                    },
                });
            });
            // SQL Server datasource
            test('sqlserver: @relation(onDelete: |)', () => {
                assertCompletion({
                    provider: 'sqlserver',
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(onDelete: |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Cascade', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'NoAction', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetNull', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetDefault', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                        ],
                    },
                });
            });
            test('sqlserver: @relation(onUpdate: |)', () => {
                assertCompletion({
                    provider: 'sqlserver',
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(onUpdate: |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Cascade', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'NoAction', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetNull', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetDefault', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                        ],
                    },
                });
            });
            test('sqlserver: @relation(fields: [orderId], references: [id], onDelete: |)', () => {
                assertCompletion({
                    provider: 'sqlserver',
                    schema: /* Prisma */ `
            model OrderItem {
              id Int @id @default(autoincrement())
              productName String
              productPrice Int
              quantity Int
              orderId Int
              order Order @relation(fields: [orderId], references: [id], onDelete: |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'Cascade', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'NoAction', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetNull', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                            { label: 'SetDefault', kind: vscode_languageserver_1.CompletionItemKind.Enum },
                        ],
                    },
                });
            });
        });
        suite('namedConstraints', function () {
            test('@id(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtId {
              orderId Int @id(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [mapProperty],
                    },
                });
            });
            test('@@id(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtIdEmpty {
              something Int
              orderId   Int
              @@id(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, nameProperty, mapProperty],
                    },
                });
            });
            test('@@id([orderId, something], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtId {
              something Int
              orderId   Int
              @@id([orderId, something], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, nameProperty, mapProperty],
                    },
                });
            });
            test('extendedIndexes: @id(|)', () => {
                assertCompletion({
                    provider: 'mysql',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `
          model Id {
            id String @id(|) @db.VarChar(3000)
          }  
          `,
                    expected: {
                        isIncomplete: false,
                        items: [mapProperty, lengthProperty],
                    },
                });
            });
            test('extendedIndexes: @@id([title(length: 100, |), abstract()])', () => {
                assertCompletion({
                    provider: 'mysql',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `
          model Fulltext {
            id      Int    @id
            title   String @db.VarChar(255)
            content String @db.Text
            
            @@fulltext()
            @@fulltext([title, content], )
          }
          model Id {
            id String @id() @db.VarChar(3000)
          }
          model IdWithLength {
            id String @id(length: 100) @db.VarChar(3000)
          }
          model Unique {
            unique Int @unique()
          }
          model CompoundId {
            id_1 String @db.VarChar(3000)
            id_2 String @db.VarChar(3000)
          
            @@id([id_1(length: 100), id_2(length: 10)])
          }
          model CompoundUnique {
            unique_1 Int
            unique_2 Int
          
            @@unique([unique_1(sort: Desc), unique_2])
          }
          model Post {
            title      String   @db.VarChar(300)
            abstract   String   @db.VarChar(3000)
            slug       String   @unique(sort: , length: 42) @db.VarChar(3000)
            slug2      String   @unique() @db.VarChar(3000)
            author     String
            created_at DateTime
          
            @@id([title(length: 100, |), abstract()])
            @@index([author, created_at(sort: )])
            @@index([author, ])
            @@index([])
          }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [lengthProperty],
                    },
                });
            });
            test('extendedIndexes: @@id([title(length: 100, ), abstract(|)])', () => {
                assertCompletion({
                    provider: 'mysql',
                    previewFeatures: ['fullTextIndex'],
                    schema: /* Prisma */ `
          model Fulltext {
            id      Int    @id
            title   String @db.VarChar(255)
            content String @db.Text
            
            @@fulltext()
            @@fulltext([title, content], )
          }
          model Id {
            id String @id() @db.VarChar(3000)
          }
          model IdWithLength {
            id String @id(length: 100) @db.VarChar(3000)
          }
          model Unique {
            unique Int @unique()
          }
          model CompoundId {
            id_1 String @db.VarChar(3000)
            id_2 String @db.VarChar(3000)
          
            @@id([id_1(length: 100), id_2(length: 10)])
          }
          model CompoundUnique {
            unique_1 Int
            unique_2 Int
          
            @@unique([unique_1(sort: Desc), unique_2])
          }
          model Post {
            title      String   @db.VarChar(300)
            abstract   String   @db.VarChar(3000)
            slug       String   @unique(sort: , length: 42) @db.VarChar(3000)
            slug2      String   @unique() @db.VarChar(3000)
            author     String
            created_at DateTime
          
            @@id([title(length: 100, ), abstract(|)])
          }
          `,
                    expected: {
                        isIncomplete: false,
                        items: [lengthProperty],
                    },
                });
            });
            test('@unique(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtUnique {
              email String @unique(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [mapProperty, sortProperty],
                    },
                });
            });
            test('@@unique(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtUniqueEmpty {
              something Int
              email     String
              @@unique(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, nameProperty, mapProperty],
                    },
                });
            });
            test('@@unique([email, something], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtUnique {
              something Int
              email     String
              @@unique([email, something], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, nameProperty, mapProperty],
                    },
                });
            });
            test('extendedIndexes: @unique(|)', () => {
                assertCompletion({
                    provider: 'mysql',
                    schema: /* Prisma */ `
            model Unique {
              unique Int @unique(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [mapProperty, lengthProperty, sortProperty],
                    },
                });
            });
            test('extendedIndexes: @unique(sort: |)', () => {
                assertCompletion({
                    provider: 'mysql',
                    schema: /* Prisma */ `
            model Post {
              slug String @unique(sort: |, length: 42) @db.VarChar(3000)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [asc, desc],
                    },
                });
            });
            test('@@index(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtIndexEmpty {
              firstName String
              lastName  String
              email     String @unique
              @@index(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
            test('@@index([firstName, lastName], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtIndex {
              firstName String
              lastName String
              @@index([firstName, lastName], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
            test('extendedIndexes: @@index([author, created_at(sort: |)])', () => {
                assertCompletion({
                    provider: 'mysql',
                    schema: /* Prisma */ `
            model Post {
              title      String   @db.VarChar(300)
              @@index([author, created_at(sort: |)])
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [asc, desc],
                    },
                });
            });
            test('extendedIndexes: @@index([author, |])', () => {
                assertCompletion({
                    provider: 'mysql',
                    schema: /* Prisma */ `
            model Post {
              title      String   @db.VarChar(300)
              abstract   String   @db.VarChar(3000)
              slug       String   @unique(length: 42) @db.VarChar(3000)
              slug2      String   @unique() @db.VarChar(3000)
              author     String
              created_at DateTime

              @@index([author, |])
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'title', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'abstract', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'slug', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'slug2', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            // { label: 'author', kind: CompletionItemKind.Field },
                            { label: 'created_at', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        ],
                    },
                });
            });
            test('extendedIndexes: @@index([|])', () => {
                assertCompletion({
                    provider: 'mysql',
                    schema: /* Prisma */ `
            model Post {
              title      String   @db.VarChar(300)
              abstract   String   @db.VarChar(3000)
              slug       String   @unique(length: 42) @db.VarChar(3000)
              slug2      String   @unique() @db.VarChar(3000)
              author     String
              created_at DateTime

              @@index([|])
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [
                            { label: 'title', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'abstract', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'slug', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'slug2', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'author', kind: vscode_languageserver_1.CompletionItemKind.Field },
                            { label: 'created_at', kind: vscode_languageserver_1.CompletionItemKind.Field },
                        ],
                    },
                });
            });
            test('@@fulltext(|)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtIndexEmpty {
              firstName String
              lastName  String
              email     String @unique
              @@index(|)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
            test('@@fulltext([firstName, lastName], |)', () => {
                assertCompletion({
                    schema: /* Prisma */ `
            model AtAtIndex {
              firstName String
              lastName String
              @@index([firstName, lastName], |)
            }`,
                    expected: {
                        isIncomplete: false,
                        items: [fieldsProperty, mapProperty],
                    },
                });
            });
        });
    });
    suite('SQL Server: clustered', () => {
        const clusteredProperty = {
            label: 'clustered',
            kind: vscode_languageserver_1.CompletionItemKind.Property,
        };
        /*
         * Block attributes
         */
        test('@@index([slug], |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String   @unique() @db.VarChar(3000)
          @@index([slug], |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldsProperty, mapProperty, clusteredProperty],
                },
            });
        });
        test('@@id([slug], |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String   @unique() @db.VarChar(3000)
          @@id([slug], |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldsProperty, nameProperty, mapProperty, clusteredProperty],
                },
            });
        });
        test('@@unique([slug], |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String   @unique() @db.VarChar(3000)
          @@unique([slug], |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [fieldsProperty, nameProperty, mapProperty, clusteredProperty],
                },
            });
        });
        /*
         * Field attributes
         */
        test('@id(|)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          unique Int @id(|)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [mapProperty, sortProperty, clusteredProperty],
                },
            });
        });
        test('@unique(|)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String @unique(|) @db.VarChar(3000)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [mapProperty, sortProperty, clusteredProperty],
                },
            });
        });
        /*
         * Values
         */
        test('@id(clustered: |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          unique Int @id(clustered: |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [staticValueTrue, staticValueFalse],
                },
            });
        });
        test('@unique(clustered: |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String  @unique(clustered: |) @db.VarChar(3000)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [staticValueTrue, staticValueFalse],
                },
            });
        });
        test('@@index([slug], clustered: |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String   @unique() @db.VarChar(3000)
          @@index([slug], clustered: |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [staticValueTrue, staticValueFalse],
                },
            });
        });
        test('@@id([slug], clustered: |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String   @unique() @db.VarChar(3000)
          @@id([slug], clustered: |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [staticValueTrue, staticValueFalse],
                },
            });
        });
        test('@@unique([slug], clustered: |)', () => {
            assertCompletion({
                provider: 'sqlserver',
                schema: /* Prisma */ `
        model Post {
          slug      String   @unique() @db.VarChar(3000)
          @@unique([slug], clustered: |)
        }`,
                expected: {
                    isIncomplete: false,
                    items: [staticValueTrue, staticValueFalse],
                },
            });
        });
    });
});
//# sourceMappingURL=completion.test.js.map